<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>創建你Github帳號上的自我介紹（Profile Repositoey）</title>
    <url>/blog/2022/10/30/create-github-profile-repository/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果有在做開發或是軟體的研究，或是研究開放的Lib，都會有接觸到版控這件事吧！<br>那你可能就有Github帳號，如果有做一些公開的Repository，你的Github帳號有機會被別人看到。<br>在你的帳號頁面(<code>https://github.com/你的帳號</code>)，就可以填入你自己的簡單個人資料。<br>但如果想要分享更多資訊給別人知道該怎麼做呢？</p>
<p>Github有提供一個特別的Repository給每個帳號，讓使用者可以自訂想要分享的資訊給大家看到。那這個Repository就是在自己帳號下創建一個跟帳號名字一樣的Repository。<br>例如：我的Github是ben890524，那我的Profile Repository就會是<code>ben890524/ben890524</code>。<br>那接下來就會有簡單的圖文來新增你自己的Profile Repository！</p>
<h2 id="新增流程"><a href="#新增流程" class="headerlink" title="新增流程"></a>新增流程</h2><h3 id="步驟一"><a href="#步驟一" class="headerlink" title="步驟一"></a>步驟一</h3><p>首先先到<a href="https://github.com/">Github</a>然後登入你的帳號。</p>
<h3 id="步驟二"><a href="#步驟二" class="headerlink" title="步驟二"></a>步驟二</h3><p>目標是新增一個新的Repository，所以點擊圖片中New的按鈕來新增新的！<br><img src="/blog/images/create-github-profile-repository/post_content_img_1.png"></p>
<h3 id="步驟三"><a href="#步驟三" class="headerlink" title="步驟三"></a>步驟三</h3><p>進入到新增Repository的設定中。<br><img src="/blog/images/create-github-profile-repository/post_content_img_2.png"><br>在<code>Repository name</code>那邊填入你的Github帳號名稱，填入後Github也會提醒你，這是一個很特別的Repository，讓你可以新增一個自己的Profile README！<br>簡單做個Description，且<strong>請記得要選公開（public）和初始化Repository時要新增一個README檔案（README.md）！</strong><br>最後就可以到最下面完成創建Repository了！</p>
<h3 id="步驟四"><a href="#步驟四" class="headerlink" title="步驟四"></a>步驟四</h3><p>要開始編輯自己的Profile了，移動到<code>你的帳號名稱/你的帳號名稱</code>下的<code>README.md</code>。<br><img src="/blog/images/create-github-profile-repository/post_content_img_3.png"><br>按下編輯鍵（一枝筆的Icon），就可以編輯專屬於你的Profile介紹了！</p>
<h3 id="步驟五"><a href="#步驟五" class="headerlink" title="步驟五"></a>步驟五</h3><p>最後等你編輯完成後，<strong>記得將你編輯的改變Commit上去Github的Repository上</strong>！<br>接下來你就可以到帳號頁面(<code>https://github.com/你的帳號</code>)看成果啦~<br><img src="/blog/images/create-github-profile-repository/post_content_img_4.png"></p>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>這是一個讓大家認識你的一個好機會，但前提也是你的Github要有曝光度XD<br>如果不喜歡Online的MarkDown編輯器的話也可以將Repository Clone下來，再本地端進行編輯~<br>也可以用其他線上的軟體撰寫好後，再貼上進行更動~</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><a href="https://docs.github.com/en/account-and-profile/setting-up-and-managing-your-github-profile/customizing-your-profile/about-your-profile">Github - About your profile</a></li>
</ul>
]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS挑戰 / CSS練習 / CSS小遊戲</title>
    <url>/blog/2022/11/02/css-challenges-practices-games/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很多人前端第一個接觸的一定就是Html和CSS，那我第一次也是高中的時候，用著作業系統內建的記事本寫著Html和CSS~XD<br>那時想知道一個新的Html Element或是想套一個新的CSS樣式，都是直接上Google找的，也很少在看書，所以學的算是零零散散的。<br>之前別人問起相關知識時，也說不出個專有名詞或要等他描述後，我才知道，所以就想說網路上，有沒有一些挑戰或是帶入遊戲可以邊學習的網站，除了可以學習到基本知識外，還有一些簡單的解釋，且在最後做完後，還可以用這個網頁來證明說，我有這些技能XD。<br>這篇就是介紹日前找到關於CSS的小挑戰，但其實可以當作一個學習知識的遊戲~~</p>
<h2 id="介紹開始"><a href="#介紹開始" class="headerlink" title="介紹開始"></a>介紹開始</h2><h3 id="CSS-Diner"><a href="#CSS-Diner" class="headerlink" title="CSS Diner"></a>CSS Diner</h3><p>CSS有很多選擇器（Selector），所以就會有很多語法。有些語法你可能看都沒有看過，但很多實務狀況就會剛好需要，在不知道這些選擇器時，你可能已經用了id或是其他方式，改了CSS的樣式。<br>了解或學了這些選擇器，他們一定會在日後幫你的（ 誤</p>
<blockquote>
<p><a href="https://flukeout.github.io/">CSS Diner</a></p>
</blockquote>
<p><img src="/blog/images/css-challenges-practices-games/post_content_img_1.png"><br>主要分成三個區塊：</p>
<ul>
<li>白色區塊：檢視目前題目的需求，會有正在動的元素，目標就是用CSS選擇器選取到他們~</li>
<li>紅色區塊：<ul>
<li>左邊是撰寫CSS選擇器的地方，只有一行。等填入答案後，可以按Enter測試答案是否正確~</li>
<li>右邊是顯示白色區塊目前的Html Element，可以移動鼠標到Html Element上，白色區塊就會顯示目前鼠標所在的元素。</li>
</ul>
</li>
<li>黃色區塊：關於題目的敘述及解釋，有一些還會有簡單的範例，所以才說這樣邊學習邊練習的方式很好吧XD</li>
</ul>
<h3 id="FLEXBOX-FROGGY"><a href="#FLEXBOX-FROGGY" class="headerlink" title="FLEXBOX FROGGY"></a>FLEXBOX FROGGY</h3><p>CSS Flexbox排版是一個容器式的排版樣式，比起傳統的position和float排版，Flexbox顯得更靈活，對現在網頁大部分要支援手機排版（RWD）來說，變得更方便了，而且在很多CSS套件&#x2F;Library裡面也會用到，例如：Bootstrap等等，所以先知道它的原理和怎麼使用一定不會虧！</p>
<blockquote>
<p><a href="https://flexboxfroggy.com/">FLEXBOX FROGGY</a></p>
</blockquote>
<p><img src="/blog/images/css-challenges-practices-games/post_content_img_2.png"><br>主要分成三個區塊：</p>
<ul>
<li>白色區塊：關於題目的敘述及解釋，且會有此CSS樣式各個屬性值的解釋，也會有簡單的範例，非常清楚~</li>
<li>黃色區塊：會顯示青蛙與荷葉，目標是讓青蛙到與他相同顏色的荷葉上且符合排版，這裡也是及時顯示結果的。</li>
<li>紅色區塊：<ul>
<li>撰寫CSS樣式的區塊，題目會告訴你最多會有幾行CSS樣式要填寫，當然後面如果你精通了，那就可以寫得更短XD。</li>
<li>只要寫出的CSS樣式是可以運行的，就會馬上反映到黃色區塊。當你完成題目需求後，紅色區塊右下角的下一關（Next）才會亮起，就可以到下一關了！</li>
</ul>
</li>
</ul>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>目前就先推薦這兩個，我玩過比較好玩的且有教學性的XD。<br>CSS選擇器相當重要，現在一些公司比較舊的專案一定會用到，或是<strong>想要為一些特殊規則的元素更改樣式，如果不想要硬加id或是用inline style寫死，一些特殊規則的選擇器會是你的好選擇</strong>~<br>Flexbox在現在非常重要，算是現今<strong>主流的一個排版系統</strong>，在<a href="https://caniuse.com/flexbox">Can I use</a>中，也有高度的普及度，而且現在要符合手機及網頁版的需求（RWD），那Flexbox是一個很靈活很符合你的選擇！</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><a href="https://flukeout.github.io/">CSS Diner</a></li>
<li><a href="https://flexboxfroggy.com/">FLEXBOX FROGGY</a></li>
</ul>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Challenge</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/blog/2022/10/27/hello-world/</url>
    <content><![CDATA[<p>這是一篇Hexo自動產生的文件<br>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>物件導向 特性 - 物件導向四大特性</title>
    <url>/blog/2022/11/04/object-oriented-features-concepts/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇要來介紹物件導向的四大概念，那就來簡單介紹物件導向是怎麼樣的概念~<br>物件導向是將大部分的程式碼變成像是物件的方式進行呈現，程式互相會是以物件的方式進行溝通。物件跟物件之間的溝通，可以想成是人與人進行溝通，每個人都會有姓名、性別、年齡等等，這些在物件就是<strong>屬性（Attributes）</strong>；每個人也都會有技能或是動作，在物件我們就稱它為<strong>方法（Methods）</strong>。<br>一個物件會由屬性跟方法所組成，但這個時候你可能會有一些困惑，如果人是一個物件，但有可能我有一些事情是不想要給別人知道的，那該怎麼辦？<br>物件的屬性和方法都有它的<strong>可視性（Visibility）</strong>，可以使比較敏感的資料不被揭露，達到資料隱藏（Information Hiding）的效果。<br>簡單的介紹完物件導向的基本後，就來介紹物件導向的四大基本概念吧~</p>
<h2 id="物件導向四大基本概念"><a href="#物件導向四大基本概念" class="headerlink" title="物件導向四大基本概念"></a>物件導向四大基本概念</h2><ol>
<li>封裝（Encapsulation）</li>
<li>抽象（Abstraction）</li>
<li>繼承（Inheritance）</li>
<li>多型（Polymorphism）</li>
</ol>
<h3 id="封裝（Encapsulation）"><a href="#封裝（Encapsulation）" class="headerlink" title="封裝（Encapsulation）"></a>封裝（Encapsulation）</h3><p>通常一個物件會有一些讀寫的限制，像是public或是private等等的限制。封裝是對一個物件的規範，物件不能將所有資訊顯露給使用者（caller），若是一個物件的部分資訊比較敏感，這些資訊又全都顯露給使用者，就會有安全的問題，可以想像使用者只要知道物件有甚麼方法，不需要知道是怎麼實作的，也就是資料隱藏（Information hiding）。</p>
<p>以下以一個C#簡單的getter和setter來解釋：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面是C#的寫法，在其他物件導向語言，大致上要表達的意思下</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">int</span> _age;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetAge</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> _age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetAge</span>(<span class="params"><span class="built_in">int</span> age</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    _age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一個Student Class有Age這個屬性（Attribute），且<code>定義&#123; get; set; &#125;</code>，代表他有public的getter和setter，皆為任何使用者都可以使用的。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面是C#的寫法，在其他物件導向語言，大致上要表達的意思下</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">int</span> _age;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetAge</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> _age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SetAge</span>(<span class="params"><span class="built_in">int</span> age</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    _age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一個Student有Age這個屬性(Attribute)，且<code>定義&#123; get; private set; &#125;</code>，代表他有public的getter和private的setter，private的setter只有在自己這個物件裡面可以被調用。</p>
<h3 id="抽象（Abstraction）"><a href="#抽象（Abstraction）" class="headerlink" title="抽象（Abstraction）"></a>抽象（Abstraction）</h3><p>會定義一個父類別，父類別會先有一線基本功能，也可以擁有一些已經被定義的方法和抽象方法，抽象方法像是abstract function或implement function，這類型的方法不能夠再父類別被實作，會在繼承的子類進行實作，但抽象方便規方便但不能濫用。</p>
<p>定義一個抽象的父類，且有抽象方法並未實作：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Bird</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>繼承抽象父類後，一定要實作父類的抽象方法：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SomeBird</span>:<span class="title">Bird</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span> =&gt; Console.WriteLine(<span class="string">&quot;I can fly.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="繼承（Inheritance）"><a href="#繼承（Inheritance）" class="headerlink" title="繼承（Inheritance）"></a>繼承（Inheritance）</h3><p>會基於某個父類別對物件的定義加以擴充，子類別可以繼承父類別原來的某些定義，並也可能增加原來的父類別所沒有的定義，或者是重新定義父類別中的某些特性（Override），但在定義父類別與繼承子類別時一定要遵守IS-A的概念。<br>IS-A概念就是：假如要使A Class繼承B Class，那A就一定要是一種B，A is a kind of B.</p>
<p>以下是bird的父類，有一個fly()的方法。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Bird</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span>&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Bird can fly.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是繼承bird父類並擴充的子類”鴿子”（Pigeon）：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Pigeon</span>:<span class="title">Bird</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">int</span> speed = <span class="number">20</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span>&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Pigeon can fly.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下列未遵守IS-A概念：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Penguin</span>:<span class="title">Bird</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span>&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Penguin ???&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>企鵝不會飛，但是卻給牠一個飛行的方法，明顯的企鵝不是一種會飛的鳥類。</p>
<h3 id="多型（Polymorphism）"><a href="#多型（Polymorphism）" class="headerlink" title="多型（Polymorphism）"></a>多型（Polymorphism）</h3><p>多型是指的是使用同一個操作介面，以操作不同的物件實例，多型操作在物件導向上是為了降低對操作介面的依賴程度，這是一種抽換概念，之後在各式Design Pattern中會常用到此概念。</p>
<p>今天有一個Service的class專門計算一台手機打折過後的價格：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SaleService</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">double</span> _discount = <span class="number">0.8</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">IphonePriceWithDiscount</span>(<span class="params">Iphone phone</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> phone.price * <span class="keyword">this</span>._discount;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">AndroidPriceWithDiscount</span>(<span class="params">Android phone</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> phone.price * <span class="keyword">this</span>._discount;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>從上述程式碼發現，如果我每有一種作業系統的手機，我就要新增一種方法去計算那種作業系統手機的價格。<br>所以定義一種操作介面為父類，讓各式作業系統的手機繼承，並對一種操作介面進行操作即可。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Phone</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">int</span> phonePrice &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Phone</span>(<span class="params"><span class="built_in">int</span> price</span>)</span>&#123;</span><br><span class="line">    phonePrice = price;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Iphone</span>:<span class="title">Phone</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Iphone</span>(<span class="params"><span class="built_in">int</span> price</span>):<span class="title">base</span>(<span class="params">price</span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Android</span>:<span class="title">Phone</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Android</span>(<span class="params"><span class="built_in">int</span> price</span>):<span class="title">base</span>(<span class="params">price</span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根據上方更改後的程式碼，可以對Service進行改造：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SaleService</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">double</span> _discount = <span class="number">0.8</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">PhonePriceWithDiscount</span>(<span class="params">Phone phone</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> phone.phonePrice * <span class="keyword">this</span>._discount;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>本篇簡單的介紹了物件導向，也介紹了物件導向的四大基本概念，封裝、抽象、繼承和多型，物件導向程式設計都會圍繞在些概念作為基礎，去做發想，有很多變化。目前很多的後端語言也都是物件導向的，像是C#、Java、Javascript等等，但也有一些不是物件導向的後端語言，像是Golang等等，所以學會物件導向設計理念後，在各個物件導向語言之間轉換，就比較不會花更多時間，就可以專心研究語言的語法跟特性上。<br>有了物件導向的概念對程式的敏感度也會上升，後續也有一些原則是建立在物件導向概念上的，像是SOLID原則，或是Design Pattern，所以把物件導向程式設計學好一定不會吃虧，我有時也會將生活中的一些東西，想成是物件XD，所以學習也可以為生活中增添一番趣味（？<br>如果本篇有誤，可以聯繫我，讓我修正QAQ，之後有空應該會介紹物件導向的五大原則SOLID~</p>
]]></content>
      <categories>
        <category>Object Oriented</category>
      </categories>
      <tags>
        <tag>Object Oriented</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>物件導向的五大原則 - SOLID</title>
    <url>/blog/2022/11/04/object-oriented-principles-solid/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>俗話說的好「不聽老人言，吃虧在眼前」，物件導向程式設計的五個基本原則是早期程式開發就存在的原則，既然能套用到至今，代表一定有它的道理，那今天就是要來窺探其中的奧妙（？<br>這些原則都同時被遵守時，它們可以使一個軟體更容易進行維護和系統的擴充變得更加彈性。那我們就來看看這些原則吧~</p>
<h2 id="SOLID為物件導向的五大原則"><a href="#SOLID為物件導向的五大原則" class="headerlink" title="SOLID為物件導向的五大原則"></a>SOLID為物件導向的五大原則</h2><ul>
<li><strong>S : Single Responsibility Principle</strong></li>
<li><strong>O : Open Close Principle</strong></li>
<li><strong>L : Liskov Substitution Principle</strong></li>
<li><strong>I : Interface Segregation Principle</strong></li>
<li><strong>D : Dependency Inversion Principle</strong></li>
</ul>
<h3 id="Single-Responsibility-Principle-單一職責原則"><a href="#Single-Responsibility-Principle-單一職責原則" class="headerlink" title="Single Responsibility Principle 單一職責原則"></a>Single Responsibility Principle 單一職責原則</h3><h4 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h4><p><strong>一個類別（class）只能負責專一的一種職責</strong>。換句話說就是，<strong>一個類別（class）中的所有，只能對一種角色負責</strong>。</p>
<p>舉例來說，今天郵差要配送一個包裹：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> 郵差&#123;</span><br><span class="line">  取得聯絡資訊()&#123;&#125;;</span><br><span class="line">  撿貨()&#123;&#125;;</span><br><span class="line">  騎車配送()&#123;&#125;;</span><br><span class="line">  送達收件者地址()&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;抵達收件者地址&quot;</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;打開郵箱並放入包裹&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這四件方法都跟送一件包裹有關，從取得收件者聯絡資訊-&gt;撿貨-&gt;騎車配送-&gt;送達收件者地址，但這四個方法中，<strong>取得收件者聯絡資訊和撿貨跟郵差完全沒有關係或是關係甚微，這部分就違反了單一職責原則</strong>。通常遇到此情況，會把與此類別無關的方法進行抽離做成其他物件。</p>
<p>接著還有一個問題，在方法<code>送達收件者地址()</code>中，進行了兩個動作，第一是抵達地址，第二是打開郵箱並放入包裹，這兩個動作也不符合單一職責原則，因為<code>送達收件者地址()</code>，做了送達收件者地址之外的事情，就是打開郵箱並放入包裹。一般來說遇到這種情況就會在抽離做一個方法。</p>
<h4 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h4><p>通常單一職責原則會希望<strong>一個類別一個方法中的內聚力（Cohesion）高一點，讓一個邏輯都在一個類別一個方法裡面做處理，不要四散各處</strong>。<strong>不讓邏輯四散各處，也降低了耦合性（Coupling）</strong>，各物件之間也不會有過多的溝通，也方便管理程式碼。</p>
<h3 id="Open-Close-Principle-開放封閉原則"><a href="#Open-Close-Principle-開放封閉原則" class="headerlink" title="Open Close Principle 開放封閉原則"></a>Open Close Principle 開放封閉原則</h3><h4 id="說明-1"><a href="#說明-1" class="headerlink" title="說明"></a>說明</h4><p>對擴展開放，而對修改封閉。修改就是把東西拆開來改，把原有的程式碼進行修改；而擴展就是對原有的東西額外加裝模組，使他符合需要更改的內容。只要變化都有成本，例如變動的難易度、變動造成的影響範圍等等都會影響到成本，若是程式碼冗長、內部邏輯複雜，類別之間互相耦合、影響範圍很廣，常常改壞東西卻不知道是哪裡造成的。使得修改很困難，讓開發效率變低。</p>
<p>通常會區分為<strong>主要邏輯和附加邏輯</strong>，將主要邏輯增加一些條件去符合成要修改的內容，這就是附加邏輯。主要邏輯通常不會進行變動，如果需要新增不同的需求，會去增加附加邏輯，讓附加邏輯達成需求，才不會對同一個主要邏輯一直修改，到最後破壞了主要邏輯。</p>
<h4 id="小結-1"><a href="#小結-1" class="headerlink" title="小結"></a>小結</h4><p><strong>以組合取代繼承</strong>。在使用繼承上，如果要增加繼承類的方法，則要整個繼承類都增加這些方法，會導致更改困難，過度耦合；但是如果採用組合，可以根據抽換的實作的類去更改實行的內容（其實也是多型的一種應用，也是後續很多設計模式的核心）。</p>
<h3 id="Liskov-Substitution-Principle-里氏替換原則"><a href="#Liskov-Substitution-Principle-里氏替換原則" class="headerlink" title="Liskov Substitution Principle 里氏替換原則"></a>Liskov Substitution Principle 里氏替換原則</h3><h4 id="說明-2"><a href="#說明-2" class="headerlink" title="說明"></a>說明</h4><p>原則的定義：<strong>子類別要能完全代理父類別的所有事情</strong>。要<strong>符合IS-A的規則，也就是SubType</strong>。<br>以下會簡單介紹如何去判別一個繼承類是否符合Liskov替換原則！</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Rectangle</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">int</span> width;</span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">int</span> height;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWidth</span>(<span class="params"><span class="built_in">int</span> w</span>)</span>&#123;</span><br><span class="line">    width = w;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHeight</span>(<span class="params"><span class="built_in">int</span> h</span>)</span>&#123;</span><br><span class="line">    height = h;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Square</span> : <span class="title">Rectangle</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWidth</span>(<span class="params"><span class="built_in">int</span> w</span>)</span>&#123;</span><br><span class="line">    width = w;</span><br><span class="line">    height = w;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHeight</span>(<span class="params"><span class="built_in">int</span> h</span>)</span>&#123;</span><br><span class="line">    height = h;</span><br><span class="line">    width = h;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根據上述矩形和繼承他的正方形來看，分成7點Liskov替換原則應遵守之條件來檢查，有沒有違反：</p>
<ol>
<li>Covariance of argument<ul>
<li>在Square中<code>public void setHeight(int h);</code>， 在Rectangle中<code>public void setHeight(int h);</code></li>
<li><strong>兩者Function傳入進去的參數數皆一致</strong>，故此條件不違反。</li>
</ul>
</li>
<li>Covariance of result<ul>
<li>在Square中<code>public void setHeight(int h);</code>， 在Rectangle中<code>public void setHeight(int h);</code></li>
<li><strong>兩者Function的回傳型態皆一致</strong>，故此條件不違反。</li>
</ul>
</li>
<li>Exception rule<ul>
<li>父類規定的內容沒有例外處理，子類也無例外處理。</li>
<li>如果父類無例外處理，子類也就不能多了例外處理；如果父類有例外處理，那子類例外處理的類別就要和父類一致。</li>
</ul>
</li>
<li>Pre-condition rule<ul>
<li>Pre-condition rule是指<strong>執行此方法前，一定要達成的條件</strong>，所以有”Pre”的稱呼。</li>
<li>此範例沒有特別的Pre-Condition。</li>
<li>其實很重要，但因為這裡例子不用判斷，所以顯得不太重要。</li>
</ul>
</li>
<li>Post-condition rule<ul>
<li>Post-condition rule是指<strong>執行此方法後，一定要達成的條件</strong>，所以有”Post”的稱呼。</li>
<li>此範例沒有特別的Post-Condition。</li>
<li>跟Pre-condition一樣，但因為這裡例子不用判斷，所以顯得不太重要。</li>
</ul>
</li>
<li>Invariant rule<ul>
<li>Invariant rule是指<strong>不管方法前後，一定要成立的條件</strong>，像是計算機，一定要是數字才能做計算。<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWidth</span>(<span class="params"><span class="built_in">int</span> w</span>)</span>&#123;</span><br><span class="line">  width = w;</span><br><span class="line">  height = w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHeight</span>(<span class="params"><span class="built_in">int</span> h</span>)</span>&#123;</span><br><span class="line">  height = h;</span><br><span class="line">  width = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在正方形的Invariant裡，規定的應該是長與寬應該要相等，所以設定長或設定寬的時候，也要一併設定對應的數值，故在此有符合。</li>
</ul>
</li>
<li>Constraint rule<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWidth</span>(<span class="params"><span class="built_in">int</span> w</span>)</span>&#123;</span><br><span class="line">  width = w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHeight</span>(<span class="params"><span class="built_in">int</span> h</span>)</span>&#123;</span><br><span class="line">  height = h;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<ul>
<li>在矩形的規則中，設定長只能設定到長，設定寬只能設定到寬，所以繼承矩形的正方形也要符合這個規則。但是正方形不符合，故違反Liskov替換原則。</li>
</ul>
</li>
</ol>
<h4 id="小結-2"><a href="#小結-2" class="headerlink" title="小結"></a>小結</h4><p><strong>繼承在沒有好的規劃、設計下，盡量不要隨意使用</strong>。因為繼承會造成很大的依賴性（Dependency），很常會因為設計或是非預期的行為，會讓你的架構越來越大，大到有些錯誤不可預期，會更難以維護。</p>
<h3 id="Interface-Segregation-Principle-介面分割原則"><a href="#Interface-Segregation-Principle-介面分割原則" class="headerlink" title="Interface Segregation Principle 介面分割原則"></a>Interface Segregation Principle 介面分割原則</h3><h4 id="說明-3"><a href="#說明-3" class="headerlink" title="說明"></a>說明</h4><p><strong>模組與模組之間的依賴，不應有用不到的功能可以被對方呼叫</strong>。每個實作都應該有契合的介面。</p>
<p>這是一台車的實作介面：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">car</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> 引擎發動();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> 油門();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> 剎車();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>今天有一台休旅車來實作car這個interface：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Suv</span> : <span class="title">car</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> 引擎發動()&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;轟隆隆隆🤣🤣隆隆隆隆衝衝衝衝😏😏😏拉風😎😎😎引擎發動🔑🔑🔑引擎發動+🚗+👉+🚗&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> 熄火()&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;0⃣到💯K only 4⃣秒鐘😏😏&quot;</span>);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> 剎車()&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;只怕警察👮♂👮♂BI BI BI 叫我路邊靠&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是正確的介面實作方法。但如果今天出現了一台噴射車車，多了一個噴射加速的功能，直接在interface car裡面新增方法，這時就違反介面分割原則，因為Suv並不會噴射加速的功能。<br>所以要新增一個噴射加速功能時，可以新增一個interface，讓有這個功能的車去實作這個介面即可，也不會去動到原有車子的介面！實作完後各interface和class如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常車會有的車功能介面</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title">car</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> 引擎發動();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> 油門();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> 剎車();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 噴射加速車會有的功能介面</span></span><br><span class="line"><span class="keyword">interface</span> 噴射加速功能&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> 噴射加速();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Suv實作正常車會有的功能介面即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Suv</span> : <span class="title">car</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> 引擎發動()&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;轟隆隆隆🤣🤣隆隆隆隆衝衝衝衝😏😏😏拉風😎😎😎引擎發動🔑🔑🔑引擎發動+🚗+👉+🚗&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> 熄火()&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;0⃣到💯K only 4⃣秒鐘😏😏&quot;</span>);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> 剎車()&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;只怕警察👮♂👮♂BI BI BI 叫我路邊靠&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 噴射加速車車實作一般車和噴射加速車功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> 噴射加速車車 : <span class="title">car</span>, 噴射加速功能&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> 引擎發動()&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;轟隆隆隆🤣🤣隆隆隆隆衝衝衝衝😏😏😏拉風😎😎😎引擎發動🔑🔑🔑引擎發動+🚗+👉+🚗&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> 熄火()&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;0⃣到💯K only 4⃣秒鐘😏😏&quot;</span>);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> 剎車()&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;只怕警察👮♂👮♂BI BI BI 叫我路邊靠&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> 噴射加速()&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;讓😯 看到的人以為是夢😱😱 還沒醒來😴😴 就已經無影無蹤👻👻&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="小結-3"><a href="#小結-3" class="headerlink" title="小結"></a>小結</h4><p>將介面分離好，只讓<strong>該實作的類別去實作、減少不必要的操作介面出現在類別中</strong>，可以讓耦合性（Coupling）更低，<strong>把實作隱藏起來、保持抽象，可以讓程式夠有彈性</strong>。</p>
<h3 id="Dependency-Inversion-Principle-依賴反轉原則"><a href="#Dependency-Inversion-Principle-依賴反轉原則" class="headerlink" title="Dependency Inversion Principle 依賴反轉原則"></a>Dependency Inversion Principle 依賴反轉原則</h3><h4 id="說明-4"><a href="#說明-4" class="headerlink" title="說明"></a>說明</h4><p><strong>高模組不應該依賴低模組，應該讓高、低模組去依賴抽象；換句話說，適當的抽象，可以讓你的程式架構有更多的彈性。</strong></p>
<p>假設今天我想要吃一個漢堡，我要吃漢堡，才會有飽足感，就是我依賴漢堡。換成程式的寫法，如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">People</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">readonly</span> Hamburger _hamburger;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">People</span>(<span class="params">Hamburger h</span>)</span>&#123;</span><br><span class="line">    _hamburger = h;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span>()</span>&#123;</span><br><span class="line">    _hamburger.eat();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;吃飽啦&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這樣哪天你像要吃薯條，或是其他甚麼食物，你都要製作新的方法，和給予空間儲存該類變數的記憶體空間。上述的寫法很依賴漢堡，沒有漢堡，People就沒有eat的方法，極度依賴。所以<strong>讓Hamburger去擁有父類別，並將父類別傳入People作為參數，這樣我今天想要吃其他食物，不用去為了新的食物去新增方法，直接增加新的食物的類別，並傳入即可，便可達到依賴反轉的效果</strong>。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 製作新的food介面</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title">Ifood</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 讓漢堡去實作food介面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Hamburger</span> : <span class="title">IFood</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span>()</span>&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;我被吃掉了QQ&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 改寫people過度依賴漢堡的寫法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">people</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">readonly</span> IFood _food;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">people</span>(<span class="params">IFood food</span>)</span>&#123;</span><br><span class="line">    _food = food;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span>()</span>&#123;</span><br><span class="line">    _food.eat();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;吃飽啦&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="小結-4"><a href="#小結-4" class="headerlink" title="小結"></a>小結</h4><p>遵守依賴反轉原則，可以减少class之間的耦合性（Coupling），也可以提高系统的可讀及維護性。而且在開發過程中，*模組之間可能經常變化，若是太過依賴低模組，會造成程式碼冗長、過度依賴，所以將依賴反轉、依賴抽象，可以降低開發時的風險**。</p>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>這些原則都很抽象，需要有實際的例子或是實際的去操作，會比較好理解，非常建議看完文章的各位，用自己的想法、構思，去實作自己的範例，會有更多的理解~那SOLID所有的原則都是為了使小至程式碼，大至整個系統架構，變得更彈性更靈活。不會讓一些小更動，讓原本的程式碼造成巨大的影響。</p>
<p>那最後用一句簡單的句子來描敘一下各個原則吧：<br><strong>S：單一類別、方法對應單一責任、降低耦合。</strong><br><strong>O：開放擴充、封閉修改。</strong><br><strong>L：類別間的相容性。</strong><br><strong>I：介面要特定目的、易懂、可再用性高。</strong><br><strong>D：抽象化，依賴抽象。</strong></p>
<p>一樣如果本篇有誤，可以聯繫我，讓我修正QAQ，希望未來可以帶給大家更好的文章~</p>
]]></content>
      <categories>
        <category>Object Oriented</category>
      </categories>
      <tags>
        <tag>Object Oriented</tag>
        <tag>C#</tag>
      </tags>
  </entry>
</search>
