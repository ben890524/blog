<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>創建你Github帳號上的自我介紹（Profile Repositoey）</title>
    <url>/blog/2022/10/30/create-github-profile-repository/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果有在做開發或是軟體的研究，或是研究開放的Lib，都會有接觸到版控這件事吧！<br>那你可能就有Github帳號，如果有做一些公開的Repository，你的Github帳號有機會被別人看到。<br>在你的帳號頁面(<code>https://github.com/你的帳號</code>)，就可以填入你自己的簡單個人資料。<br>但如果想要分享更多資訊給別人知道該怎麼做呢？</p>
<p>Github有提供一個特別的Repository給每個帳號，讓使用者可以自訂想要分享的資訊給大家看到。那這個Repository就是在自己帳號下創建一個跟帳號名字一樣的Repository。<br>例如：我的Github是ben890524，那我的Profile Repository就會是<code>ben890524/ben890524</code>。<br>那接下來就會有簡單的圖文來新增你自己的Profile Repository！</p>
<h2 id="新增流程"><a href="#新增流程" class="headerlink" title="新增流程"></a>新增流程</h2><h3 id="步驟一"><a href="#步驟一" class="headerlink" title="步驟一"></a>步驟一</h3><p>首先先到<a href="https://github.com/">Github</a>然後登入你的帳號。</p>
<h3 id="步驟二"><a href="#步驟二" class="headerlink" title="步驟二"></a>步驟二</h3><p>目標是新增一個新的Repository，所以點擊圖片中New的按鈕來新增新的！<br><img src="/blog/images/create-github-profile-repository/post_content_img_1.png"></p>
<h3 id="步驟三"><a href="#步驟三" class="headerlink" title="步驟三"></a>步驟三</h3><p>進入到新增Repository的設定中。<br><img src="/blog/images/create-github-profile-repository/post_content_img_2.png"><br>在<code>Repository name</code>那邊填入你的Github帳號名稱，填入後Github也會提醒你，這是一個很特別的Repository，讓你可以新增一個自己的Profile README！<br>簡單做個Description，且<strong>請記得要選公開（public）和初始化Repository時要新增一個README檔案（README.md）！</strong><br>最後就可以到最下面完成創建Repository了！</p>
<h3 id="步驟四"><a href="#步驟四" class="headerlink" title="步驟四"></a>步驟四</h3><p>要開始編輯自己的Profile了，移動到<code>你的帳號名稱/你的帳號名稱</code>下的<code>README.md</code>。<br><img src="/blog/images/create-github-profile-repository/post_content_img_3.png"><br>按下編輯鍵（一枝筆的Icon），就可以編輯專屬於你的Profile介紹了！</p>
<h3 id="步驟五"><a href="#步驟五" class="headerlink" title="步驟五"></a>步驟五</h3><p>最後等你編輯完成後，<strong>記得將你編輯的改變Commit上去Github的Repository上</strong>！<br>接下來你就可以到帳號頁面(<code>https://github.com/你的帳號</code>)看成果啦~<br><img src="/blog/images/create-github-profile-repository/post_content_img_4.png"></p>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>這是一個讓大家認識你的一個好機會，但前提也是你的Github要有曝光度XD<br>如果不喜歡Online的MarkDown編輯器的話也可以將Repository Clone下來，再本地端進行編輯~<br>也可以用其他線上的軟體撰寫好後，再貼上進行更動~</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><a href="https://docs.github.com/en/account-and-profile/setting-up-and-managing-your-github-profile/customizing-your-profile/about-your-profile">Github - About your profile</a></li>
</ul>
]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS挑戰 / CSS練習 / CSS小遊戲</title>
    <url>/blog/2022/11/02/css-challenges-practices-games/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很多人前端第一個接觸的一定就是Html和CSS，那我第一次也是高中的時候，用著作業系統內建的記事本寫著Html和CSS~XD<br>那時想知道一個新的Html Element或是想套一個新的CSS樣式，都是直接上Google找的，也很少在看書，所以學的算是零零散散的。<br>之前別人問起相關知識時，也說不出個專有名詞或要等他描述後，我才知道，所以就想說網路上，有沒有一些挑戰或是帶入遊戲可以邊學習的網站，除了可以學習到基本知識外，還有一些簡單的解釋，且在最後做完後，還可以用這個網頁來證明說，我有這些技能XD。<br>這篇就是介紹日前找到關於CSS的小挑戰，但其實可以當作一個學習知識的遊戲~~</p>
<h2 id="介紹開始"><a href="#介紹開始" class="headerlink" title="介紹開始"></a>介紹開始</h2><h3 id="CSS-Diner"><a href="#CSS-Diner" class="headerlink" title="CSS Diner"></a>CSS Diner</h3><p>CSS有很多選擇器（Selector），所以就會有很多語法。有些語法你可能看都沒有看過，但很多實務狀況就會剛好需要，在不知道這些選擇器時，你可能已經用了id或是其他方式，改了CSS的樣式。<br>了解或學了這些選擇器，他們一定會在日後幫你的（ 誤</p>
<blockquote>
<p><a href="https://flukeout.github.io/">CSS Diner</a></p>
</blockquote>
<p><img src="/blog/images/css-challenges-practices-games/post_content_img_1.png"><br>主要分成三個區塊：</p>
<ul>
<li>白色區塊：檢視目前題目的需求，會有正在動的元素，目標就是用CSS選擇器選取到他們~</li>
<li>紅色區塊：<ul>
<li>左邊是撰寫CSS選擇器的地方，只有一行。等填入答案後，可以按Enter測試答案是否正確~</li>
<li>右邊是顯示白色區塊目前的Html Element，可以移動鼠標到Html Element上，白色區塊就會顯示目前鼠標所在的元素。</li>
</ul>
</li>
<li>黃色區塊：關於題目的敘述及解釋，有一些還會有簡單的範例，所以才說這樣邊學習邊練習的方式很好吧XD</li>
</ul>
<h3 id="FLEXBOX-FROGGY"><a href="#FLEXBOX-FROGGY" class="headerlink" title="FLEXBOX FROGGY"></a>FLEXBOX FROGGY</h3><p>CSS Flexbox排版是一個容器式的排版樣式，比起傳統的position和float排版，Flexbox顯得更靈活，對現在網頁大部分要支援手機排版（RWD）來說，變得更方便了，而且在很多CSS套件&#x2F;Library裡面也會用到，例如：Bootstrap等等，所以先知道它的原理和怎麼使用一定不會虧！</p>
<blockquote>
<p><a href="https://flexboxfroggy.com/">FLEXBOX FROGGY</a></p>
</blockquote>
<p><img src="/blog/images/css-challenges-practices-games/post_content_img_2.png"><br>主要分成三個區塊：</p>
<ul>
<li>白色區塊：關於題目的敘述及解釋，且會有此CSS樣式各個屬性值的解釋，也會有簡單的範例，非常清楚~</li>
<li>黃色區塊：會顯示青蛙與荷葉，目標是讓青蛙到與他相同顏色的荷葉上且符合排版，這裡也是及時顯示結果的。</li>
<li>紅色區塊：<ul>
<li>撰寫CSS樣式的區塊，題目會告訴你最多會有幾行CSS樣式要填寫，當然後面如果你精通了，那就可以寫得更短XD。</li>
<li>只要寫出的CSS樣式是可以運行的，就會馬上反映到黃色區塊。當你完成題目需求後，紅色區塊右下角的下一關（Next）才會亮起，就可以到下一關了！</li>
</ul>
</li>
</ul>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>目前就先推薦這兩個，我玩過比較好玩的且有教學性的XD。<br>CSS選擇器相當重要，現在一些公司比較舊的專案一定會用到，或是<strong>想要為一些特殊規則的元素更改樣式，如果不想要硬加id或是用inline style寫死，一些特殊規則的選擇器會是你的好選擇</strong>~<br>Flexbox在現在非常重要，算是現今<strong>主流的一個排版系統</strong>，在<a href="https://caniuse.com/flexbox">Can I use</a>中，也有高度的普及度，而且現在要符合手機及網頁版的需求（RWD），那Flexbox是一個很靈活很符合你的選擇！</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><a href="https://flukeout.github.io/">CSS Diner</a></li>
<li><a href="https://flexboxfroggy.com/">FLEXBOX FROGGY</a></li>
</ul>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Challenge</tag>
      </tags>
  </entry>
  <entry>
    <title>前端知識區 / 前端面試題</title>
    <url>/blog/2022/12/16/frontend-knowledge/</url>
    <content><![CDATA[<h1 id="For-Front-End-Learning"><a href="#For-Front-End-Learning" class="headerlink" title="For Front-End Learning"></a>For Front-End Learning</h1><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><blockquote>
<p><a href="https://www.daconote.com/span-div-difference/">行內元素&amp;區塊元素</a></p>
</blockquote>
<h2 id="Css"><a href="#Css" class="headerlink" title="Css"></a>Css</h2><blockquote>
<p><a href="https://changtsuiling.gitbooks.io/sass/content/chapter1/1-1-shi-me-shi-css-yu-chu-li-qi-ff1f.html">Css 預處理器 Pre-procesor</a><br><a href="https://injerry.pixnet.net/blog/post/38847966#:~:text=%E9%81%B8%E5%8F%96%E5%99%A8%EF%BC%88Selector%EF%BC%89%EF%BC%8C%E4%B9%9F%E6%9C%89,%E9%80%99%E6%A8%A3%E7%BF%BB%E8%AD%AF%E4%B9%9F%E5%B0%8D%E5%95%A6%EF%BC%89">CSS 選擇器 Selector</a><br><a href="https://ithelp.ithome.com.tw/articles/10196454">CSS 權重</a><br><a href="https://www.oxxostudio.tw/articles/202008/css-box-model.html">CSS Box Model</a><br><a href="https://ithelp.ithome.com.tw/articles/10196528?sc=rss.qu">CSS Reset &#x2F; Normalized</a><br><a href="https://www.facebook.com/groups/f2e.tw/permalink/4925715637465762/">網上推的 CSS 面試題目</a></p>
</blockquote>
<ol>
<li>每一個瀏覽器在定義每一個HTML標籤時用的style不一樣，會出現你的應用程式前端在各個瀏覽器顯示出來的結果可能不一樣，所以製作出reset.css，強制讓Browser的基本屬性變為你設定的值，讓不統一的地方一致，缺點是不彈性。所以後續解決這個問題，才多了CSS Normalize去繼承Browser原有的CSS屬性，再去做加法。</li>
<li>哪種CSS會被蓋掉、哪種CSS權重比較重，在同樣指定的CSS上，哪一個會被套用。簡單來說important&gt;inline-style&gt;id&gt;class&#x3D;attribute&#x3D;psuedo-class&gt;html-element。</li>
<li>html tags中的box element，由外往內有margin、border、padding和content。</li>
</ol>
<blockquote>
<p><a href="https://w3c.hexschool.com/blog/35afa83f">CSS BEM設計模式</a><br><a href="https://blog.yuyansoftware.com.tw/2022/02/css-cascade-layers-specificity/">CSS Cascade Layers @layer 解決css權重</a><br><a href="https://blog.hiskio.com/tailwind-css-or-bootstrap/">Tailwind css v.s Bootstrap</a></p>
</blockquote>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><blockquote>
<p><a href="https://ithelp.ithome.com.tw/articles/10190873">JS 基本中的基本</a><br><a href="https://shawnlin0201.github.io/JavaScript/JavaScript-Automatic-Semicolon-Insertion/">JS Automatic Semicolon</a><br><a href="https://medium.com/helena-chang/js%E4%BA%8C%E9%83%A8%E6%9B%B2-%E7%AB%8B%E5%8D%B3%E5%87%BD%E5%BC%8F-iife-b60bd694bbea">JS IIFE</a><br><a href="https://ithelp.ithome.com.tw/articles/10266627">JS 宣告提升 Hoisting</a><br><a href="https://ithelp.ithome.com.tw/articles/10265819">JS 冒泡事件 Bubble Event</a><br><a href="https://hackmd.io/@Heidi-Liu/note-fe201-dom">JS 冒泡事件&#x2F;事件捕獲 Event Bubbling&#x2F;Event Capturing</a><br><a href="https://pjchender.dev/javascript/js-closure/">JS 閉包 Closure</a><br><a href="https://medium.com/take-a-day-off/js-scope-%E4%BD%9C%E7%94%A8%E5%9F%9F-ee536640963b">JS 作用域 Scope</a><br><a href="https://pjchender.dev/javascript/js-promise/">JS Promise</a><br><a href="https://medium.com/itsems-frontend/javascript-event-loop-event-queue-call-stack-74a02fed5625">JS Event Loop</a><br><a href="https://medium.com/@mengchiang000/js%E5%9F%BA%E6%9C%AC%E8%A7%80%E5%BF%B5-%E5%8E%9F%E5%9E%8B%E9%8F%88-prototype-chain-96c742893795">JS 原型鏈 Prototype Chain</a></p>
</blockquote>
<h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><h2 id="Browser"><a href="#Browser" class="headerlink" title="Browser"></a>Browser</h2><blockquote>
<p><a href="https://notfalse.net/7/three-way-handshake">TCP 三向交握</a><br><a href="https://ithelp.ithome.com.tw/articles/10250980">Http Methods</a><br><a href="https://ithelp.ithome.com.tw/articles/10238084">CORS</a><br><a href="https://ithelp.ithome.com.tw/articles/10235079">DOM v.s BOM</a><br><a href="https://5xruby.tw/posts/what-is-jwt">JWT JSON Web Token</a><br><a href="https://shubo.io/rendering-patterns/">SSR v.s CSR</a><br><a href="https://medium.com/@bebebobohaha/cookie-localstorage-sessionstorage-%E5%B7%AE%E7%95%B0-9e1d5df3dd7f">LocalStorage v.s SessionStorage v.s Cookie</a><br><a href="https://caniuse.com/">What Can I use?</a><br><a href="https://ikala.cloud/grpc-openapi-and-rest-1/#:~:text=gRPC%20%E6%98%AF%E4%B8%80%E7%A8%AE%E5%AF%A6%E4%BD%9C,%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F%E8%88%87%E6%AD%A4%E7%9B%B8%E5%8F%8D%E3%80%82">REST v.s gRPC v.s OpenAPI</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Frontend</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Frontend</tag>
        <tag>Html</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/blog/2022/10/27/hello-world/</url>
    <content><![CDATA[<p>這是一篇Hexo自動產生的文件<br>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Nuxt3介紹</title>
    <url>/blog/2022/12/16/nuxt3-introduction/</url>
    <content><![CDATA[<h1 id="Nuxt3-簡介"><a href="#Nuxt3-簡介" class="headerlink" title="Nuxt3 簡介"></a>Nuxt3 簡介</h1><h2 id="Nuxt3-template-x2F-Nuxt3-starter"><a href="#Nuxt3-template-x2F-Nuxt3-starter" class="headerlink" title="Nuxt3 template &#x2F; Nuxt3 starter"></a>Nuxt3 template &#x2F; Nuxt3 starter</h2><h5 id="一個自製的nuxt3-template"><a href="#一個自製的nuxt3-template" class="headerlink" title="一個自製的nuxt3 template"></a><a href="https://github.com/ben890524/nuxt3-template">一個自製的nuxt3 template</a></h5><ul>
<li>nuxt3 stable</li>
<li>tailwindcss</li>
<li>pinia &amp; pinia-plugin-persistedstate</li>
<li>i18n(@intlify&#x2F;nuxt3) and store in pinia-persist</li>
<li>simple template for page&#x2F;layout&#x2F;error</li>
</ul>
<h2 id="Description-簡述-："><a href="#Description-簡述-：" class="headerlink" title="Description(簡述)："></a>Description(簡述)：</h2><p>Nuxt3 是以 Vue3 為基礎，用來在單頁應用程式（SPA, Single Page Application）上進行伺服器渲染（SSR, Server Side Render）。專案架構打包工具支援 webpack 5 和 Vite，且使用 Vue-Router 來管理客戶端（Client Side）的路由。但目前版本還在釋出版本候補（RC, Release Candidate），代表還相對不穩定，現階段比較建議使用 Npm、Yarn，其他套件管理程式（Package Manager）的支援度還不夠，例如 PNpM。<br>2022&#x2F;11&#x2F;16，Nuxt3 已經在今天正式釋出<a href="https://github.com/nuxt/framework/discussions/9064">穩定版本</a>！！！</p>
<h3 id="SSR-V-S-CSR"><a href="#SSR-V-S-CSR" class="headerlink" title="SSR V.S CSR"></a>SSR V.S CSR</h3><h4 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h4><p>HTML 網頁資料會在伺服器端進行編譯，編譯完成才會回傳回客戶端，大多後端 MVC 架構的網頁皆是 SSR。</p>
<h5 id="優點"><a href="#優點" class="headerlink" title="優點"></a>優點</h5><ul>
<li>搜尋引擎優化（SEO）的排名更佳。</li>
<li>使用者進到的首屏（第一屏）速度較快，因為不用下載 JS 和 CSS 檔執行後才看到頁面。</li>
<li>性能不好的手機或是網路不好的區域，在首屏（第一屏）畫面渲染也比較快。</li>
</ul>
<h5 id="缺點"><a href="#缺點" class="headerlink" title="缺點"></a>缺點</h5><ul>
<li>伺服器端會有更大的壓力，因為部分程式碼會在伺服器端執行。</li>
</ul>
<h4 id="CSR"><a href="#CSR" class="headerlink" title="CSR"></a>CSR</h4><p>所有 HTML 網頁資料都交給客戶端進行渲染，會等到 JS 和 CSS 檔完成執行後才會顯示畫面，也些是依照 Router 去顯示的，也會等 API 資料回傳後才顯示。</p>
<h5 id="優點-1"><a href="#優點-1" class="headerlink" title="優點"></a>優點</h5><ul>
<li>減少伺服器端的負荷，因為所有都是在客戶端上進行渲染。</li>
</ul>
<h5 id="缺點-1"><a href="#缺點-1" class="headerlink" title="缺點"></a>缺點</h5><ul>
<li>SEO 排名極差，因為一開始 HTNL 會是空白的，所以網頁爬蟲機器人會爬不到資料。</li>
<li>首屏頁面渲染速度慢，因為要等 JS 和 CSS 下載完後才會有畫面。</li>
</ul>
<h4 id="SSR-amp-CSR-總結"><a href="#SSR-amp-CSR-總結" class="headerlink" title="SSR&amp;CSR 總結"></a>SSR&amp;CSR 總結</h4><p>一些內部管理系統，追求效率或是操作平凡的系統就比較推薦使用 CSR；<br>高度需要 SEO 的就推薦使用 SSR，像是媒體平台或是電商平台，這類型的就需要被搜尋引擎搜尋到，就需要 SSR。</p>
<h3 id="Nuxt-在-SSR-上的運作原理"><a href="#Nuxt-在-SSR-上的運作原理" class="headerlink" title="Nuxt 在 SSR 上的運作原理"></a>Nuxt 在 SSR 上的運作原理</h3><p>因應 SSR，所以 Nuxt 在原理上，就是在 Server Side 先執行過一次後，再 Client Side 再執行一次，第一次的執行比較可以應對 SEO 或是搜尋引擎的爬蟲機器人，第二次就是給一般的使用者做正常的網頁使用。</p>
<h2 id="用途："><a href="#用途：" class="headerlink" title="用途："></a>用途：</h2><p>將 SPA 和 SSR 的好處結合在一起。在首個屏幕的頁面渲染較快，且支援良好的 SEO，且之後採用客戶端渲染（CSR, Client Side Render）的方式執行。所以常常會被同構、Hybird、混合等等的形容詞形容。</p>
<h2 id="準備專案"><a href="#準備專案" class="headerlink" title="準備專案"></a>準備專案</h2><h3 id="創建專案"><a href="#創建專案" class="headerlink" title="創建專案"></a>創建專案</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx nuxi init [nuxt-app]</span><br><span class="line"><span class="built_in">cd</span> [nuxt-app]</span><br></pre></td></tr></table></figure>

<p>若途中有詢問你是否要安裝<a href="mailto:&#x6e;&#x75;&#120;&#116;&#64;&#x33;&#x2e;&#48;&#46;&#48;&#45;&#114;&#99;">&#x6e;&#x75;&#120;&#116;&#64;&#x33;&#x2e;&#48;&#46;&#48;&#45;&#114;&#99;</a>.*，請按 Y。</p>
<h3 id="安裝依賴"><a href="#安裝依賴" class="headerlink" title="安裝依賴"></a>安裝依賴</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>推薦使用 Npm、Yarn 套件管理程式，PNpM 現階段要加參數（–shamefully-hoist）才可正常 Install。</p>
<h3 id="啟動開發伺服器"><a href="#啟動開發伺服器" class="headerlink" title="啟動開發伺服器"></a>啟動開發伺服器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn dev</span><br><span class="line">npm run dev</span><br><span class="line">pnpm dev</span><br></pre></td></tr></table></figure>

<p>推薦使用 Npm、Yarn 套件管理程式。也可以在<code>package.json</code>新增跟 vue3 一樣的啟動指令！</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In package.json</span></span><br><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">&quot;serve&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nuxt dev&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm serve</span><br><span class="line">yarn serve</span><br><span class="line">pnpm serve</span><br></pre></td></tr></table></figure>

<h2 id="Nuxt-的檔案架構（Directory-Structure）"><a href="#Nuxt-的檔案架構（Directory-Structure）" class="headerlink" title="Nuxt 的檔案架構（Directory Structure）"></a>Nuxt 的檔案架構（Directory Structure）</h2><p>Nuxt 的檔案結構大致上如下，下面會依次來做簡單介紹：<br><img src="https://i.imgur.com/6oaKlII.png"></p>
<h3 id="nuxt"><a href="#nuxt" class="headerlink" title=".nuxt"></a>.nuxt</h3><p>Nuxt 用這個資料夾裡面的 Script，在 Devlopment 時產生 Vue 的應用程式。<br><strong><em>官方建議是完全都不要碰，不然會在執行 nuxt dev 時，將&#x2F;.nuxt 目錄重新建立。</em></strong><br><strong><del>想了解有關 Nuxt 根據目錄結構生成的更多信息，可以往這個資料夾裡面的東西找。</del></strong></p>
<h3 id="output"><a href="#output" class="headerlink" title=".output"></a>.output</h3><p>當你跑 Script 為了建立 Production(或是其他測試環境)的應用程式時，產出的檔案會被放在這個資料夾。<br><strong><em>官方建議是完全都不要碰，不然會在執行 nuxt dev 時，將&#x2F;.nuxt 目錄重新建立。</em></strong></p>
<h3 id="assets"><a href="#assets" class="headerlink" title="assets"></a>assets</h3><p>可以放置網站所有的靜態資產，例如：階層樣式表(CSS)、字體樣式和圖片等等，專案架構打包工具(webpack 5 和 Vite)會處理到。</p>
<h3 id="components"><a href="#components" class="headerlink" title="components"></a>components</h3><p>用來放置 Vue Component 的地方，這些 Components 用來之後可以匯入進頁面(pages)裡面，且達成重複利用的效果。<br>具有 Auto Import Components 的功能，不需要再各個頁面進行 Import，但 Auto Import 有它的限制。<br>下面兩種都是在&#x2F;components 底下，在頁面上皆可用 &lt; Footer &#x2F;&gt; 的方式取出來。<br><img src="https://i.imgur.com/PosHoYL.png"><br><img src="https://i.imgur.com/8gMu3QX.png"><br>若是是有用資料夾進行分類的，且分類底下還有更小的 component 的話，也有對應的 Auto Import 功能。<br><img src="https://i.imgur.com/5O3fbrn.png"><br>在 header 裡面的 SlideMenu 就可以用 header-slide-menu 或 HeaderSlideMenu 進行使用。<br><img src="https://i.imgur.com/zxQPmT5.png"><br>目前還是推薦使用自己 Import 進來的命名的方式，去 Import 各 Component，因為這樣編輯器(Visual Studio Code)可以追蹤的到，以開發維護的角度來看，比較方便。</p>
<h3 id="composables"><a href="#composables" class="headerlink" title="composables"></a>composables</h3><p>用來放置 Vue Composables，這些 Composables 用來之後可以在任何頁面進行使用、運算。<br>且也支援 Auto Import Composables。<br>在&#x2F;composables 裡定義好，在 script setup 裡面，就可以直接使用你定義好的 composables。<br><img src="https://i.imgur.com/3OI9quZ.png"><br><img src="https://i.imgur.com/llJZ7V7.png"><br>一般的命名還是會以 Vue3 一貫的 Composition Api 的方式去命名，以 use 為開頭！</p>
<h3 id="content"><a href="#content" class="headerlink" title="content"></a>content</h3><p>Nuxt 的 Content 會讀取 content&#x2F;目錄並解析.md、.yml、.csv 和.json 的文件，後產生以檔案為基礎的 CMS。</p>
<h3 id="layouts"><a href="#layouts" class="headerlink" title="layouts"></a>layouts</h3><p>Nuxt 提供了一個可自由制定的佈局框架，可以在整個應用程式中使用，非常適合將常見的可重用的佈局組件中，就可以迅速的在不同的內容頁面套用不同的樣板。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 透過這樣的方式可以替換layout</span></span><br><span class="line"><span class="title function_">definePageMeta</span>(&#123;</span><br><span class="line">  <span class="attr">layout</span>: <span class="string">&#x27;custom&#x27;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>或是在 Vue template 裡面用 NuxtLayout 來做呈現：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 透過這樣的方式指定layout</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">NuxtLayout</span> <span class="attr">name</span>=<span class="string">&quot;layout-name&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">NuxtLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="middleware"><a href="#middleware" class="headerlink" title="middleware"></a>middleware</h3><p>Nuxt 提供一個可定制的路由中間件框架，就是 Middleware，可以在整個應用程序中使用，非常適合在轉導時，之前使用 Middleware 進行一些額外的操作。<br>實作方面可以參考：</p>
<ul>
<li><a href="https://book.vue.tw/CH4/4-4-navigation-guards.html">路由守衛（Navigation Guards）</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10295114">[Day 5] 認識 Nuxt3 專案結構 - middleware</a></li>
</ul>
<h4 id="第一種中介層：全域的中介層"><a href="#第一種中介層：全域的中介層" class="headerlink" title="第一種中介層：全域的中介層"></a>第一種中介層：全域的中介層</h4><p>在 middleware 資料夾裡，有任何命名內有.global 的檔案(.ts file)，都會被當成全域的中介層，在每一個 route 時都會執行。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.global.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineNuxtPlugin</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">addRouteMiddleware</span>(<span class="string">&#x27;global&#x27;</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      ...something;</span><br><span class="line">    &#125;,&#123; <span class="attr">global</span>: <span class="literal">true</span> &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="第二種中介層：指定的中介層"><a href="#第二種中介層：指定的中介層" class="headerlink" title="第二種中介層：指定的中介層"></a>第二種中介層：指定的中介層</h4><p>可以為你想要的頁面客製化 middleware，然後在頁面 setup 的區塊註冊 middleware。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// xxx.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineNuxtRouteMiddleware</span>(<span class="keyword">async</span> (_to, _from) =&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// account.vue</span></span><br><span class="line">&lt;script setup lang=<span class="string">&quot;ts&quot;</span>&gt;</span><br><span class="line">    <span class="title function_">definePageMeta</span>(&#123;</span><br><span class="line">      <span class="attr">middleware</span>: [<span class="string">&#x27;account&#x27;</span>],</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="node-modules"><a href="#node-modules" class="headerlink" title="node_modules"></a>node_modules</h3><p>套件管理程式（Npm、Yarn 和 PNpM 等等）會創建&#x2F;node_modules，用來存儲此專案所有的依賴套件。</p>
<h3 id="pages"><a href="#pages" class="headerlink" title="pages"></a>pages</h3><p>Nuxt 依照 pages 資料夾目錄下面的內容，使用 Vue-Router 創建出來，所以資料夾的路徑即是網址的路徑，有一點像靜態路由。</p>
<h3 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h3><p>Nuxt 提供自動讀取 plugins 資料夾中的檔案，並在執行的時候自動加載。在 plugin 裡面的檔案要使用<strong>defineNuxtPlugin</strong>去定義讓 nuxtapp 使用。也可以在檔案名中增加.server 或.client 的後綴命名，讓 plugins 只在伺服器端或是客戶端中被執行。<br>使用 Nuxt 內建的 NuxtLink 進行跳轉的時候，Nuxt 的頁面是不會幫你把頁面跳到置頂與置左的，所以就可以透過設定 plugin 的方式解決：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// router.global.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineNuxtPlugin</span>(<span class="function">(<span class="params">nuxtApp</span>) =&gt;</span> &#123;</span><br><span class="line">  nuxtApp.<span class="title function_">hook</span>(<span class="string">&#x27;page:finish&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(&#123; <span class="attr">top</span>: <span class="number">0</span>, <span class="attr">left</span>: <span class="number">0</span> &#125;), <span class="number">300</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>因為 plugin 會自動載入，所以這樣就可以達成所有的 Page 結束的同時，頁面的位置會幫你置頂置左。</p>
<h3 id="public"><a href="#public" class="headerlink" title="public"></a>public</h3><p>public&#x2F;資料夾下直接在服務器根目錄提供必須保留其名稱（例如 robots.txt）或可能不會更改（例如 favicon.ico）的公共檔案。</p>
<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p>因為 Nuxt 是運行在伺服器端上的，所以可以有一些後端的操作，就會放在這個資料夾裡面。但還是希望說前後端分離的架構上，可以依照權責分工，除了一些特殊的需求。<br>主要會有下面幾個操作：</p>
<ul>
<li>~&#x2F;server&#x2F;api</li>
<li>~&#x2F;server&#x2F;routes</li>
<li>~&#x2F;server&#x2F;middleware</li>
</ul>
<h3 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h3><p>.gitignore 文件定義了 git 要忽略或是不追蹤的檔案。可以去到 git 官網看更多。</p>
<h3 id="nuxtignore"><a href="#nuxtignore" class="headerlink" title=".nuxtignore"></a>.nuxtignore</h3><p>Nuxt 提供了.nuxtignore 讓構建階段（Build Phase）時忽略跟目錄中的佈局（layouts）、頁面（pages）、元件（components）、（composables）和（middleware）中介層文件。</p>
<h3 id="app-config-ts"><a href="#app-config-ts" class="headerlink" title="app.config.ts"></a>app.config.ts</h3><p>Nuxt 3 提供了 app.config 的配置文件來控制響應式配置，並能夠在生命週期內運行時更新，或者使用 Nuxt 插件並使用 HMR 熱更新（Hot Module Replacement）對其進行改變後馬上更新。</p>
<blockquote>
<p>Hot Module Replacement，就是在 Server 與瀏覽器建立了一個 websocket 連線，當程式碼被修改時，Server 會傳送訊息通知瀏覽器去請求修改模組的程式碼，完成熱更新，所以在這樣的情況下就能在不刷新瀏覽器的前提下進行更新。HMR 具有以下優點：</p>
<ol>
<li>修改程式碼時，可以即時更新畫面</li>
<li>實現部分跟新，避免多餘請求</li>
<li>保有原本狀態</li>
</ol>
</blockquote>
<h3 id="app-vue"><a href="#app-vue" class="headerlink" title="app.vue"></a>app.vue</h3><p>這是 Nuxt 應用程式中，最主要的原件。</p>
<h3 id="nuxt-config-ts"><a href="#nuxt-config-ts" class="headerlink" title="nuxt.config.ts"></a>nuxt.config.ts</h3><p>Nuxt 提供 nuxt.config 檔案可以快速配置具有.js、.ts 或.mjs 等副檔名的檔案。</p>
<h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p>package.json 檔案包含此 Nuxt 應用程式的所有依賴的套件、腳本，和其的版本。</p>
<h3 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h3><p>此檔案是.nuxt&#x2F;tsconfig.json 的擴充檔，可以依照專案的需求，對需要的設定進行客製化的調整。</p>
<h6 id="HackMD-網址"><a href="#HackMD-網址" class="headerlink" title="HackMD 網址"></a><a href="https://hackmd.io/VZaRGDuXS8avfcF0g62qpg">HackMD 網址</a></h6><h6 id="tags-Nuxt3-SSR"><a href="#tags-Nuxt3-SSR" class="headerlink" title="tags: Nuxt3 SSR"></a>tags: <code>Nuxt3</code> <code>SSR</code></h6>]]></content>
      <categories>
        <category>Nuxt3</category>
      </categories>
      <tags>
        <tag>Nuxt3</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>物件導向 特性 - 物件導向四大特性</title>
    <url>/blog/2022/11/04/object-oriented-features-concepts/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇要來介紹物件導向的四大概念，那就來簡單介紹物件導向是怎麼樣的概念~<br>物件導向是將大部分的程式碼變成像是物件的方式進行呈現，程式互相會是以物件的方式進行溝通。物件跟物件之間的溝通，可以想成是人與人進行溝通，每個人都會有姓名、性別、年齡等等，這些在物件就是<strong>屬性（Attributes）</strong>；每個人也都會有技能或是動作，在物件我們就稱它為<strong>方法（Methods）</strong>。<br>一個物件會由屬性跟方法所組成，但這個時候你可能會有一些困惑，如果人是一個物件，但有可能我有一些事情是不想要給別人知道的，那該怎麼辦？<br>物件的屬性和方法都有它的<strong>可視性（Visibility）</strong>，可以使比較敏感的資料不被揭露，達到資料隱藏（Information Hiding）的效果。<br>簡單的介紹完物件導向的基本後，就來介紹物件導向的四大基本概念吧~</p>
<h2 id="物件導向四大基本概念"><a href="#物件導向四大基本概念" class="headerlink" title="物件導向四大基本概念"></a>物件導向四大基本概念</h2><ol>
<li>封裝（Encapsulation）</li>
<li>抽象（Abstraction）</li>
<li>繼承（Inheritance）</li>
<li>多型（Polymorphism）</li>
</ol>
<h3 id="封裝（Encapsulation）"><a href="#封裝（Encapsulation）" class="headerlink" title="封裝（Encapsulation）"></a>封裝（Encapsulation）</h3><p>通常一個物件會有一些讀寫的限制，像是public或是private等等的限制。封裝是對一個物件的規範，物件不能將所有資訊顯露給使用者（caller），若是一個物件的部分資訊比較敏感，這些資訊又全都顯露給使用者，就會有安全的問題，可以想像使用者只要知道物件有甚麼方法，不需要知道是怎麼實作的，也就是資料隱藏（Information hiding）。</p>
<p>以下以一個C#簡單的getter和setter來解釋：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面是C#的寫法，在其他物件導向語言，大致上要表達的意思下</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">int</span> _age;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetAge</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> _age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetAge</span>(<span class="params"><span class="built_in">int</span> age</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    _age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一個Student Class有Age這個屬性（Attribute），且<code>定義&#123; get; set; &#125;</code>，代表他有public的getter和setter，皆為任何使用者都可以使用的。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面是C#的寫法，在其他物件導向語言，大致上要表達的意思下</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">int</span> _age;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetAge</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> _age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SetAge</span>(<span class="params"><span class="built_in">int</span> age</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    _age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一個Student有Age這個屬性(Attribute)，且<code>定義&#123; get; private set; &#125;</code>，代表他有public的getter和private的setter，private的setter只有在自己這個物件裡面可以被調用。</p>
<h3 id="抽象（Abstraction）"><a href="#抽象（Abstraction）" class="headerlink" title="抽象（Abstraction）"></a>抽象（Abstraction）</h3><p>會定義一個父類別，父類別會先有一線基本功能，也可以擁有一些已經被定義的方法和抽象方法，抽象方法像是abstract function或implement function，這類型的方法不能夠再父類別被實作，會在繼承的子類進行實作，但抽象方便規方便但不能濫用。</p>
<p>定義一個抽象的父類，且有抽象方法並未實作：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Bird</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>繼承抽象父類後，一定要實作父類的抽象方法：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SomeBird</span>:<span class="title">Bird</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span> =&gt; Console.WriteLine(<span class="string">&quot;I can fly.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="繼承（Inheritance）"><a href="#繼承（Inheritance）" class="headerlink" title="繼承（Inheritance）"></a>繼承（Inheritance）</h3><p>會基於某個父類別對物件的定義加以擴充，子類別可以繼承父類別原來的某些定義，並也可能增加原來的父類別所沒有的定義，或者是重新定義父類別中的某些特性（Override），但在定義父類別與繼承子類別時一定要遵守IS-A的概念。<br>IS-A概念就是：假如要使A Class繼承B Class，那A就一定要是一種B，A is a kind of B.</p>
<p>以下是bird的父類，有一個fly()的方法。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Bird</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span>&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Bird can fly.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是繼承bird父類並擴充的子類”鴿子”（Pigeon）：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Pigeon</span>:<span class="title">Bird</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">int</span> speed = <span class="number">20</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span>&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Pigeon can fly.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下列未遵守IS-A概念：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Penguin</span>:<span class="title">Bird</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span>&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Penguin ???&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>企鵝不會飛，但是卻給牠一個飛行的方法，明顯的企鵝不是一種會飛的鳥類。</p>
<h3 id="多型（Polymorphism）"><a href="#多型（Polymorphism）" class="headerlink" title="多型（Polymorphism）"></a>多型（Polymorphism）</h3><p>多型是指的是使用同一個操作介面，以操作不同的物件實例，多型操作在物件導向上是為了降低對操作介面的依賴程度，這是一種抽換概念，之後在各式Design Pattern中會常用到此概念。</p>
<p>今天有一個Service的class專門計算一台手機打折過後的價格：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SaleService</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">double</span> _discount = <span class="number">0.8</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">IphonePriceWithDiscount</span>(<span class="params">Iphone phone</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> phone.price * <span class="keyword">this</span>._discount;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">AndroidPriceWithDiscount</span>(<span class="params">Android phone</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> phone.price * <span class="keyword">this</span>._discount;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>從上述程式碼發現，如果我每有一種作業系統的手機，我就要新增一種方法去計算那種作業系統手機的價格。<br>所以定義一種操作介面為父類，讓各式作業系統的手機繼承，並對一種操作介面進行操作即可。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Phone</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">int</span> phonePrice &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Phone</span>(<span class="params"><span class="built_in">int</span> price</span>)</span>&#123;</span><br><span class="line">    phonePrice = price;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Iphone</span>:<span class="title">Phone</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Iphone</span>(<span class="params"><span class="built_in">int</span> price</span>):<span class="title">base</span>(<span class="params">price</span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Android</span>:<span class="title">Phone</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Android</span>(<span class="params"><span class="built_in">int</span> price</span>):<span class="title">base</span>(<span class="params">price</span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根據上方更改後的程式碼，可以對Service進行改造：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SaleService</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">double</span> _discount = <span class="number">0.8</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">PhonePriceWithDiscount</span>(<span class="params">Phone phone</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> phone.phonePrice * <span class="keyword">this</span>._discount;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>本篇簡單的介紹了物件導向，也介紹了物件導向的四大基本概念，封裝、抽象、繼承和多型，物件導向程式設計都會圍繞在些概念作為基礎，去做發想，有很多變化。目前很多的後端語言也都是物件導向的，像是C#、Java、Javascript等等，但也有一些不是物件導向的後端語言，像是Golang等等，所以學會物件導向設計理念後，在各個物件導向語言之間轉換，就比較不會花更多時間，就可以專心研究語言的語法跟特性上。<br>有了物件導向的概念對程式的敏感度也會上升，後續也有一些原則是建立在物件導向概念上的，像是SOLID原則，或是Design Pattern，所以把物件導向程式設計學好一定不會吃虧，我有時也會將生活中的一些東西，想成是物件XD，所以學習也可以為生活中增添一番趣味（？<br>如果本篇有誤，可以聯繫我，讓我修正QAQ，之後有空應該會介紹物件導向的五大原則SOLID~</p>
]]></content>
      <categories>
        <category>Object Oriented</category>
      </categories>
      <tags>
        <tag>Object Oriented</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>物件導向的五大原則 - SOLID</title>
    <url>/blog/2022/11/04/object-oriented-principles-solid/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>俗話說的好「不聽老人言，吃虧在眼前」，物件導向程式設計的五個基本原則是早期程式開發就存在的原則，既然能套用到至今，代表一定有它的道理，那今天就是要來窺探其中的奧妙（？<br>這些原則都同時被遵守時，它們可以使一個軟體更容易進行維護和系統的擴充變得更加彈性。那我們就來看看這些原則吧~</p>
<h2 id="SOLID為物件導向的五大原則"><a href="#SOLID為物件導向的五大原則" class="headerlink" title="SOLID為物件導向的五大原則"></a>SOLID為物件導向的五大原則</h2><ul>
<li><strong>S : Single Responsibility Principle</strong></li>
<li><strong>O : Open Close Principle</strong></li>
<li><strong>L : Liskov Substitution Principle</strong></li>
<li><strong>I : Interface Segregation Principle</strong></li>
<li><strong>D : Dependency Inversion Principle</strong></li>
</ul>
<h3 id="Single-Responsibility-Principle-單一職責原則"><a href="#Single-Responsibility-Principle-單一職責原則" class="headerlink" title="Single Responsibility Principle 單一職責原則"></a>Single Responsibility Principle 單一職責原則</h3><h4 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h4><p><strong>一個類別（class）只能負責專一的一種職責</strong>。換句話說就是，<strong>一個類別（class）中的所有，只能對一種角色負責</strong>。</p>
<p>舉例來說，今天郵差要配送一個包裹：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> 郵差&#123;</span><br><span class="line">  取得聯絡資訊()&#123;&#125;;</span><br><span class="line">  撿貨()&#123;&#125;;</span><br><span class="line">  騎車配送()&#123;&#125;;</span><br><span class="line">  送達收件者地址()&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;抵達收件者地址&quot;</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;打開郵箱並放入包裹&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這四件方法都跟送一件包裹有關，從取得收件者聯絡資訊-&gt;撿貨-&gt;騎車配送-&gt;送達收件者地址，但這四個方法中，<strong>取得收件者聯絡資訊和撿貨跟郵差完全沒有關係或是關係甚微，這部分就違反了單一職責原則</strong>。通常遇到此情況，會把與此類別無關的方法進行抽離做成其他物件。</p>
<p>接著還有一個問題，在方法<code>送達收件者地址()</code>中，進行了兩個動作，第一是抵達地址，第二是打開郵箱並放入包裹，這兩個動作也不符合單一職責原則，因為<code>送達收件者地址()</code>，做了送達收件者地址之外的事情，就是打開郵箱並放入包裹。一般來說遇到這種情況就會在抽離做一個方法。</p>
<h4 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h4><p>通常單一職責原則會希望<strong>一個類別一個方法中的內聚力（Cohesion）高一點，讓一個邏輯都在一個類別一個方法裡面做處理，不要四散各處</strong>。<strong>不讓邏輯四散各處，也降低了耦合性（Coupling）</strong>，各物件之間也不會有過多的溝通，也方便管理程式碼。</p>
<h3 id="Open-Close-Principle-開放封閉原則"><a href="#Open-Close-Principle-開放封閉原則" class="headerlink" title="Open Close Principle 開放封閉原則"></a>Open Close Principle 開放封閉原則</h3><h4 id="說明-1"><a href="#說明-1" class="headerlink" title="說明"></a>說明</h4><p>對擴展開放，而對修改封閉。修改就是把東西拆開來改，把原有的程式碼進行修改；而擴展就是對原有的東西額外加裝模組，使他符合需要更改的內容。只要變化都有成本，例如變動的難易度、變動造成的影響範圍等等都會影響到成本，若是程式碼冗長、內部邏輯複雜，類別之間互相耦合、影響範圍很廣，常常改壞東西卻不知道是哪裡造成的。使得修改很困難，讓開發效率變低。</p>
<p>通常會區分為<strong>主要邏輯和附加邏輯</strong>，將主要邏輯增加一些條件去符合成要修改的內容，這就是附加邏輯。主要邏輯通常不會進行變動，如果需要新增不同的需求，會去增加附加邏輯，讓附加邏輯達成需求，才不會對同一個主要邏輯一直修改，到最後破壞了主要邏輯。</p>
<h4 id="小結-1"><a href="#小結-1" class="headerlink" title="小結"></a>小結</h4><p><strong>以組合取代繼承</strong>。在使用繼承上，如果要增加繼承類的方法，則要整個繼承類都增加這些方法，會導致更改困難，過度耦合；但是如果採用組合，可以根據抽換的實作的類去更改實行的內容（其實也是多型的一種應用，也是後續很多設計模式的核心）。</p>
<h3 id="Liskov-Substitution-Principle-里氏替換原則"><a href="#Liskov-Substitution-Principle-里氏替換原則" class="headerlink" title="Liskov Substitution Principle 里氏替換原則"></a>Liskov Substitution Principle 里氏替換原則</h3><h4 id="說明-2"><a href="#說明-2" class="headerlink" title="說明"></a>說明</h4><p>原則的定義：<strong>子類別要能完全代理父類別的所有事情</strong>。要<strong>符合IS-A的規則，也就是SubType</strong>。<br>以下會簡單介紹如何去判別一個繼承類是否符合Liskov替換原則！</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Rectangle</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">int</span> width;</span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">int</span> height;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWidth</span>(<span class="params"><span class="built_in">int</span> w</span>)</span>&#123;</span><br><span class="line">    width = w;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHeight</span>(<span class="params"><span class="built_in">int</span> h</span>)</span>&#123;</span><br><span class="line">    height = h;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Square</span> : <span class="title">Rectangle</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWidth</span>(<span class="params"><span class="built_in">int</span> w</span>)</span>&#123;</span><br><span class="line">    width = w;</span><br><span class="line">    height = w;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHeight</span>(<span class="params"><span class="built_in">int</span> h</span>)</span>&#123;</span><br><span class="line">    height = h;</span><br><span class="line">    width = h;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根據上述矩形和繼承他的正方形來看，分成7點Liskov替換原則應遵守之條件來檢查，有沒有違反：</p>
<ol>
<li>Covariance of argument<ul>
<li>在Square中<code>public void setHeight(int h);</code>， 在Rectangle中<code>public void setHeight(int h);</code></li>
<li><strong>兩者Function傳入進去的參數數皆一致</strong>，故此條件不違反。</li>
</ul>
</li>
<li>Covariance of result<ul>
<li>在Square中<code>public void setHeight(int h);</code>， 在Rectangle中<code>public void setHeight(int h);</code></li>
<li><strong>兩者Function的回傳型態皆一致</strong>，故此條件不違反。</li>
</ul>
</li>
<li>Exception rule<ul>
<li>父類規定的內容沒有例外處理，子類也無例外處理。</li>
<li>如果父類無例外處理，子類也就不能多了例外處理；如果父類有例外處理，那子類例外處理的類別就要和父類一致。</li>
</ul>
</li>
<li>Pre-condition rule<ul>
<li>Pre-condition rule是指<strong>執行此方法前，一定要達成的條件</strong>，所以有”Pre”的稱呼。</li>
<li>此範例沒有特別的Pre-Condition。</li>
<li>其實很重要，但因為這裡例子不用判斷，所以顯得不太重要。</li>
</ul>
</li>
<li>Post-condition rule<ul>
<li>Post-condition rule是指<strong>執行此方法後，一定要達成的條件</strong>，所以有”Post”的稱呼。</li>
<li>此範例沒有特別的Post-Condition。</li>
<li>跟Pre-condition一樣，但因為這裡例子不用判斷，所以顯得不太重要。</li>
</ul>
</li>
<li>Invariant rule<ul>
<li>Invariant rule是指<strong>不管方法前後，一定要成立的條件</strong>，像是計算機，一定要是數字才能做計算。<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWidth</span>(<span class="params"><span class="built_in">int</span> w</span>)</span>&#123;</span><br><span class="line">  width = w;</span><br><span class="line">  height = w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHeight</span>(<span class="params"><span class="built_in">int</span> h</span>)</span>&#123;</span><br><span class="line">  height = h;</span><br><span class="line">  width = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在正方形的Invariant裡，規定的應該是長與寬應該要相等，所以設定長或設定寬的時候，也要一併設定對應的數值，故在此有符合。</li>
</ul>
</li>
<li>Constraint rule<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWidth</span>(<span class="params"><span class="built_in">int</span> w</span>)</span>&#123;</span><br><span class="line">  width = w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHeight</span>(<span class="params"><span class="built_in">int</span> h</span>)</span>&#123;</span><br><span class="line">  height = h;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<ul>
<li>在矩形的規則中，設定長只能設定到長，設定寬只能設定到寬，所以繼承矩形的正方形也要符合這個規則。但是正方形不符合，故違反Liskov替換原則。</li>
</ul>
</li>
</ol>
<h4 id="小結-2"><a href="#小結-2" class="headerlink" title="小結"></a>小結</h4><p><strong>繼承在沒有好的規劃、設計下，盡量不要隨意使用</strong>。因為繼承會造成很大的依賴性（Dependency），很常會因為設計或是非預期的行為，會讓你的架構越來越大，大到有些錯誤不可預期，會更難以維護。</p>
<h3 id="Interface-Segregation-Principle-介面分割原則"><a href="#Interface-Segregation-Principle-介面分割原則" class="headerlink" title="Interface Segregation Principle 介面分割原則"></a>Interface Segregation Principle 介面分割原則</h3><h4 id="說明-3"><a href="#說明-3" class="headerlink" title="說明"></a>說明</h4><p><strong>模組與模組之間的依賴，不應有用不到的功能可以被對方呼叫</strong>。每個實作都應該有契合的介面。</p>
<p>這是一台車的實作介面：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">car</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> 引擎發動();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> 油門();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> 剎車();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>今天有一台休旅車來實作car這個interface：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Suv</span> : <span class="title">car</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> 引擎發動()&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;轟隆隆隆🤣🤣隆隆隆隆衝衝衝衝😏😏😏拉風😎😎😎引擎發動🔑🔑🔑引擎發動+🚗+👉+🚗&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> 熄火()&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;0⃣到💯K only 4⃣秒鐘😏😏&quot;</span>);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> 剎車()&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;只怕警察👮♂👮♂BI BI BI 叫我路邊靠&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是正確的介面實作方法。但如果今天出現了一台噴射車車，多了一個噴射加速的功能，直接在interface car裡面新增方法，這時就違反介面分割原則，因為Suv並不會噴射加速的功能。<br>所以要新增一個噴射加速功能時，可以新增一個interface，讓有這個功能的車去實作這個介面即可，也不會去動到原有車子的介面！實作完後各interface和class如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常車會有的車功能介面</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title">car</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> 引擎發動();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> 油門();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> 剎車();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 噴射加速車會有的功能介面</span></span><br><span class="line"><span class="keyword">interface</span> 噴射加速功能&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> 噴射加速();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Suv實作正常車會有的功能介面即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Suv</span> : <span class="title">car</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> 引擎發動()&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;轟隆隆隆🤣🤣隆隆隆隆衝衝衝衝😏😏😏拉風😎😎😎引擎發動🔑🔑🔑引擎發動+🚗+👉+🚗&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> 熄火()&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;0⃣到💯K only 4⃣秒鐘😏😏&quot;</span>);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> 剎車()&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;只怕警察👮♂👮♂BI BI BI 叫我路邊靠&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 噴射加速車車實作一般車和噴射加速車功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> 噴射加速車車 : <span class="title">car</span>, 噴射加速功能&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> 引擎發動()&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;轟隆隆隆🤣🤣隆隆隆隆衝衝衝衝😏😏😏拉風😎😎😎引擎發動🔑🔑🔑引擎發動+🚗+👉+🚗&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> 熄火()&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;0⃣到💯K only 4⃣秒鐘😏😏&quot;</span>);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> 剎車()&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;只怕警察👮♂👮♂BI BI BI 叫我路邊靠&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> 噴射加速()&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;讓😯 看到的人以為是夢😱😱 還沒醒來😴😴 就已經無影無蹤👻👻&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="小結-3"><a href="#小結-3" class="headerlink" title="小結"></a>小結</h4><p>將介面分離好，只讓<strong>該實作的類別去實作、減少不必要的操作介面出現在類別中</strong>，可以讓耦合性（Coupling）更低，<strong>把實作隱藏起來、保持抽象，可以讓程式夠有彈性</strong>。</p>
<h3 id="Dependency-Inversion-Principle-依賴反轉原則"><a href="#Dependency-Inversion-Principle-依賴反轉原則" class="headerlink" title="Dependency Inversion Principle 依賴反轉原則"></a>Dependency Inversion Principle 依賴反轉原則</h3><h4 id="說明-4"><a href="#說明-4" class="headerlink" title="說明"></a>說明</h4><p><strong>高模組不應該依賴低模組，應該讓高、低模組去依賴抽象；換句話說，適當的抽象，可以讓你的程式架構有更多的彈性。</strong></p>
<p>假設今天我想要吃一個漢堡，我要吃漢堡，才會有飽足感，就是我依賴漢堡。換成程式的寫法，如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">People</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">readonly</span> Hamburger _hamburger;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">People</span>(<span class="params">Hamburger h</span>)</span>&#123;</span><br><span class="line">    _hamburger = h;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span>()</span>&#123;</span><br><span class="line">    _hamburger.eat();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;吃飽啦&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這樣哪天你像要吃薯條，或是其他甚麼食物，你都要製作新的方法，和給予空間儲存該類變數的記憶體空間。上述的寫法很依賴漢堡，沒有漢堡，People就沒有eat的方法，極度依賴。所以<strong>讓Hamburger去擁有父類別，並將父類別傳入People作為參數，這樣我今天想要吃其他食物，不用去為了新的食物去新增方法，直接增加新的食物的類別，並傳入即可，便可達到依賴反轉的效果</strong>。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 製作新的food介面</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title">Ifood</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 讓漢堡去實作food介面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Hamburger</span> : <span class="title">IFood</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span>()</span>&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;我被吃掉了QQ&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 改寫people過度依賴漢堡的寫法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">people</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">readonly</span> IFood _food;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">people</span>(<span class="params">IFood food</span>)</span>&#123;</span><br><span class="line">    _food = food;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span>()</span>&#123;</span><br><span class="line">    _food.eat();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;吃飽啦&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="小結-4"><a href="#小結-4" class="headerlink" title="小結"></a>小結</h4><p>遵守依賴反轉原則，可以减少class之間的耦合性（Coupling），也可以提高系统的可讀及維護性。而且在開發過程中，*模組之間可能經常變化，若是太過依賴低模組，會造成程式碼冗長、過度依賴，所以將依賴反轉、依賴抽象，可以降低開發時的風險**。</p>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>這些原則都很抽象，需要有實際的例子或是實際的去操作，會比較好理解，非常建議看完文章的各位，用自己的想法、構思，去實作自己的範例，會有更多的理解~那SOLID所有的原則都是為了使小至程式碼，大至整個系統架構，變得更彈性更靈活。不會讓一些小更動，讓原本的程式碼造成巨大的影響。</p>
<p>那最後用一句簡單的句子來描敘一下各個原則吧：<br><strong>S：單一類別、方法對應單一責任、降低耦合。</strong><br><strong>O：開放擴充、封閉修改。</strong><br><strong>L：類別間的相容性。</strong><br><strong>I：介面要特定目的、易懂、可再用性高。</strong><br><strong>D：抽象化，依賴抽象。</strong></p>
<p>一樣如果本篇有誤，可以聯繫我，讓我修正QAQ，希望未來可以帶給大家更好的文章~</p>
]]></content>
      <categories>
        <category>Object Oriented</category>
      </categories>
      <tags>
        <tag>Object Oriented</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 實作 Google reCAPTCHA / Google 非機器人驗證</title>
    <url>/blog/2022/12/21/vue-google-recaptcha/</url>
    <content><![CDATA[<h1 id="Vue-實作-Google-reCAPTCHA-x2F-Google-非機器人驗證"><a href="#Vue-實作-Google-reCAPTCHA-x2F-Google-非機器人驗證" class="headerlink" title="Vue 實作 Google reCAPTCHA &#x2F; Google 非機器人驗證"></a>Vue 實作 Google reCAPTCHA &#x2F; Google 非機器人驗證</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因為工作上的需要，所以要來研究 Google reCAPTCHA，公司是用 Vue，所以會來用 Vue 來實做看看，後續看看能不能整合進去公司的 Nuxt3 的前台。<del>最下面有本次實作的範例檔案，有需要可以直接取 XD</del></p>
<h2 id="Google-reCAPTCHA"><a href="#Google-reCAPTCHA" class="headerlink" title="Google reCAPTCHA"></a>Google reCAPTCHA</h2><p>因為網站安全性問題，或是要防止機器人來到你的網站，佔用你的伺服器空間，所以很多網站都會連接 Google reCAPTCHA，來讓 Google 幫你檢驗，當前使用者是不是機器人~<br>這功能應該很常見，想必大家一定有看過一個勾勾旁邊是我不是機器人，或是一個九宮格請你選取題目指示的圖片，這些都是 Google reCAPTCHA 的實作。<br>Google reCAPTCHA 主要有以下幾種：</p>
<ol>
<li>google reCAPTCHA v2<ul>
<li><img src="/blog/images/vue-google-recaptcha/post_content_img_1.png"></li>
<li>會有一個核取框，問你是不是機器人，在 google 的檢查機制下如果覺得你是機器人，就會出現九宮格選取框，再來依照題目的要求選取即可。</li>
</ul>
</li>
<li>google reCAPTCHA v3<ul>
<li>全在背景執行，google 會給當前使用者進行評分，從 0.0~1.0，開發者可以自行決定，多少分以下視為機器人！</li>
</ul>
</li>
<li>google reCAPTCHA 企業版<ul>
<li>目前據了解，會有更多管理上的功能，且也不會有驗證次數上的限制，因為<strong>reCAPTCHA v2 v3 有每個月一百萬次</strong>的上限！</li>
</ul>
</li>
</ol>
<h2 id="註冊-Google-reCAPTCHA"><a href="#註冊-Google-reCAPTCHA" class="headerlink" title="註冊 Google reCAPTCHA"></a>註冊 Google reCAPTCHA</h2><p>先到<a href="https://www.google.com/recaptcha/about/">Google reCAPTCHA</a>，選取紅色框框的<code>v3 Admin Console</code>。</p>
<p><img src="/blog/images/vue-google-recaptcha/post_content_img_2.png"></p>
<p>接下來填入一些基本的資料進行註冊吧！有幾點可以注意：</p>
<ul>
<li>reCAPTCHA v2 v3 依自己的需求使用，如果都需要則要分為兩個進行創立</li>
<li>網站可以填入 127.0.0.1 和 localhost，如有需要可以填自己區網的 ip</li>
</ul>
<p><img src="/blog/images/vue-google-recaptcha/post_content_img_3.png"></p>
<p>提交後，就可以看到金鑰了，可以不用複製，後續進到 Google reCAPTCHA 的站台還是可以看到~在前端(Vue)會使用到的都只會是<code>網站金鑰</code>！</p>
<p><img src="/blog/images/vue-google-recaptcha/post_content_img_4.png"></p>
<p>那 Google reCAPTCHA 的註冊前置的部分就到這邊，可以去準備 Vue 的環境了，這邊 reCAPTCHA v2 v3 都會實作，所以要去註冊兩個~~~</p>
<p><img src="/blog/images/vue-google-recaptcha/post_content_img_5.png"></p>
<h2 id="建立-Vue-專案"><a href="#建立-Vue-專案" class="headerlink" title="建立 Vue 專案"></a>建立 Vue 專案</h2><p>那現在就先簡單的建立 Vue3 Template：</p>
<ul>
<li>使用 Vue3</li>
<li>Vite</li>
<li>Typescript</li>
</ul>
<p>可以使用你喜歡的套件管理器，以下範例皆使用 pnpm。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pnpm create vite@latest vue3-recaptcha -- --template vue-ts</span><br><span class="line"><span class="built_in">cd</span> vue3-recaptcha-example</span><br><span class="line">pnpm install</span><br><span class="line">pnpm run dev</span><br></pre></td></tr></table></figure>

<p>先檢測看看是否能正常啟動~</p>
<h2 id="實作-reCAPTCHA-v2"><a href="#實作-reCAPTCHA-v2" class="headerlink" title="實作 reCAPTCHA v2"></a>實作 reCAPTCHA v2</h2><p>可以正常啟動後，先下載套件<a href="https://www.npmjs.com/package/vue3-recaptcha2">vue3-recaptcha2</a>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pnpm install vue3-recaptcha2</span><br></pre></td></tr></table></figure>

<p>然後建立 GoogleReCaptchaV2.vue 進行 import，這邊簡單的建立，可以依需求 import 在各個地方！</p>
<p><img src="/blog/images/vue-google-recaptcha/post_content_img_6.png"></p>
<p>接下來來實作 GoogleReCaptchaV2.vue：<br>我習慣將相關的方法用類似物件的方式封裝關聯起來：</p>
<figure class="highlight typescript"><figcaption><span>GoogleReCaptchaV2.vue</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;script setup lang=<span class="string">&quot;ts&quot;</span>&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> vueRecaptcha <span class="keyword">from</span> <span class="string">&#x27;vue3-recaptcha2&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> instance_vueRecaptchaV2 = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="comment">// 請換成你註冊的 SiteKey</span></span><br><span class="line">  <span class="comment">// Please change to your SiteKey.</span></span><br><span class="line">  <span class="attr">data_v2SiteKey</span>: <span class="string">&#x27;*****************************&#x27;</span>,</span><br><span class="line">  <span class="attr">recaptchaVerified</span>: <span class="function">(<span class="params">response_token: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response_token);</span><br><span class="line">    <span class="comment">// 連接後端API，給後端進行認證</span></span><br><span class="line">    <span class="comment">// Connect to your Backend service.</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">recaptchaExpired</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 驗證過期後進行的動作</span></span><br><span class="line">    <span class="comment">// After recaptcha is expired, the action you can do.</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;驗證過期啦QAQ&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">recaptchaFailed</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 驗證失敗進行的動作</span></span><br><span class="line">    <span class="comment">// After recaptcha is failed, the action you can do.</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><figcaption><span>GoogleReCaptchaV2.vue</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">vue-recaptcha</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:sitekey</span>=<span class="string">&quot;instance_vueRecaptchaV2.data_v2SiteKey&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">size</span>=<span class="string">&quot;normal&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">theme</span>=<span class="string">&quot;light&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">hl</span>=<span class="string">&quot;zh-TW&quot;</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">verify</span>=<span class="string">&quot;instance_vueRecaptchaV2.recaptchaVerified&quot;</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">expire</span>=<span class="string">&quot;instance_vueRecaptchaV2.recaptchaExpired&quot;</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">fail</span>=<span class="string">&quot;instance_vueRecaptchaV2.recaptchaFailed&quot;</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接下來在頁面上就可以看到，目前沒有調整樣式，可以依照需求去調整~<br>可以在 Component 階段用一個 div 包著，import 後進行排版！</p>
<p><img src="/blog/images/vue-google-recaptcha/post_content_img_7.png"></p>
<p>可以簡單測試看看，點擊我不是機器人後，核取筐會打勾，且在開發人員的 Console 也有印出這次 reCAPTCHA 的 Token，再去連接後端進行認證即可~</p>
<p><img src="/blog/images/vue-google-recaptcha/post_content_img_8.png"></p>
<p>當驗證過期時，功能也都正常，就可以依照需求進行操作啦！</p>
<p><img src="/blog/images/vue-google-recaptcha/post_content_img_9.png"></p>
<p>那到這邊，就已經完成了 Google reCAPTCHA v2 的 Vue 實作了！</p>
<h2 id="實作-reCAPTCHA-v3"><a href="#實作-reCAPTCHA-v3" class="headerlink" title="實作 reCAPTCHA v3"></a>實作 reCAPTCHA v3</h2><p>接下來要實作 reCAPTCHA v3，先下載套件<a href="https://www.npmjs.com/package/vue-recaptcha-v3">vue-recaptcha-v3</a>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pnpm install vue-recaptcha-v3</span><br></pre></td></tr></table></figure>

<p>再來到 main.ts 對 vue-recaptcha-v3 進行註冊，其中<a href="https://github.com/AurityLab/recaptcha-v3/#load-options-usage">loaderOptions</a>可以在 vue-recaptcha-v3 套件說明這邊依照自己的需求選取。</p>
<figure class="highlight typescript"><figcaption><span>main.ts</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./style.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">VueReCaptcha</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-recaptcha-v3&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>);</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title class_">VueReCaptcha</span>, &#123;</span><br><span class="line">  <span class="comment">// 請換成你註冊的 SiteKey</span></span><br><span class="line">  <span class="comment">// Please change to your SiteKey.</span></span><br><span class="line">  <span class="attr">siteKey</span>: <span class="string">&#x27;*****************************&#x27;</span>,</span><br><span class="line">  <span class="attr">loaderOptions</span>: &#123;</span><br><span class="line">    <span class="attr">useRecaptchaNet</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>進行註冊完後，你就可以發現在畫面右下角有 Google reCAPTCHA v3 的圖標，這個圖標也可以用 Css style 強制隱藏。</p>
<p><img src="/blog/images/vue-google-recaptcha/post_content_img_10.png"></p>
<p>但如果你是<strong>使用 TypeScript+Vue3 的 OptionApi</strong>，就需要在 src 檔案目錄下新增<code>shims-vue-recaptcha-v3.d.ts</code>，才可以正常使用，如果是<strong>CompositionApi 則可以跳過</strong>！</p>
<figure class="highlight typescript"><figcaption><span>shims-vue-recaptcha-v3.d.ts</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ReCaptchaInstance</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;recaptcha-v3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;@vue/runtime-core&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">ComponentCustomProperties</span> &#123;</span><br><span class="line">    <span class="attr">$recaptcha</span>: <span class="function">(<span class="params">action: <span class="built_in">string</span></span>) =&gt;</span> <span class="title class_">Promise</span>&lt;<span class="built_in">string</span>&gt;</span><br><span class="line">    <span class="attr">$recaptchaLoaded</span>: <span class="function">() =&gt;</span> <span class="title class_">Promise</span>&lt;<span class="built_in">boolean</span>&gt;</span><br><span class="line">    <span class="attr">$recaptchaInstance</span>: <span class="title class_">ReCaptchaInstance</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接著建立 GoogleReCaptchaV3.vue 進行 import，可以依需求 import 在各個地方！但這邊比較要注意的是 reCAPTCHA v3 主要是使用者在進行某一個事件時觸發，像是登入或是註冊發送表單的時候進行，這邊先以 Button 當作觸發條件！</p>
<figure class="highlight typescript"><figcaption><span>GoogleReCaptchaV3.vue</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;script setup lang=<span class="string">&quot;ts&quot;</span>&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useReCaptcha &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-recaptcha-v3&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> &#123; executeRecaptcha, recaptchaLoaded &#125; = <span class="title function_">useReCaptcha</span>()!;</span><br><span class="line"><span class="keyword">const</span> instance_vueRecaptchaV3 = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">executeRecaptcha</span>: <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// (可選) 等待直到 recaptcha 載入完成</span></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">recaptchaLoaded</span>();</span><br><span class="line">    <span class="comment">// 執行 &quot;login&quot; 狀態的 reCAPTCHA</span></span><br><span class="line">    <span class="keyword">const</span> token = <span class="keyword">await</span> <span class="title function_">executeRecaptcha</span>(<span class="string">&#x27;login&#x27;</span>);</span><br><span class="line">    <span class="comment">// 後續傳給後端進行認證</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(token);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><figcaption><span>GoogleReCaptchaV3.vue</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;v3-margin&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">click</span>=<span class="string">&quot;instance_vueRecaptchaV3.executeRecaptcha&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">        Submit to active reCAPTCHA</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span> <span class="attr">lang</span>=<span class="string">&quot;css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.v3-margin</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>並在需要的地方進行 import：</p>
<p><img src="/blog/images/vue-google-recaptcha/post_content_img_11.png"></p>
<p>在畫面上就可以看到觸發 reCAPTCHA 的 Button，按下去也可以觸發功能：</p>
<p><img src="/blog/images/vue-google-recaptcha/post_content_img_12.png"></p>
<p>那由於<a href="https://www.npmjs.com/package/vue-recaptcha-v3">vue-recaptcha-v3</a>，提供的方式是使用<strong>provide&#x2F;inject</strong>的方式進行註冊，所以所有<strong>有關套件的操作都要在 vue 的 setup 狀態</strong>進行。<br>但依照上面的範例，所有狀態觸發都綁定在 Button 上面觸發，相對不彈性，所以將它額外移出去，到新建立的 Composable 去實作。我這邊想到的方法是建立 Composable：useReCaptchaV3.ts，提供一個方法，當要使用發法的時候，傳 vue-recaptcha-v3 的實例(Instance)進去即可，相關實作如下：<br>建立 useReCaptchaV3.ts，並實作：</p>
<figure class="highlight typescript"><figcaption><span>useReCaptchaV3.ts</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">IReCaptchaComposition</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-recaptcha-v3&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">useReCaptchaV3</span>(<span class="params">useReCaptcha: IReCaptchaComposition</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; executeRecaptcha, recaptchaLoaded &#125; = useReCaptcha;</span><br><span class="line">  <span class="comment">// (可選) 等待直到 recaptcha 載入完成</span></span><br><span class="line">  <span class="comment">// (optional) Wait until recaptcha has been loaded.</span></span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">recaptchaLoaded</span>();</span><br><span class="line">  <span class="comment">// 執行 &quot;login&quot; 狀態的 reCAPTCHA</span></span><br><span class="line">  <span class="comment">// Execute reCAPTCHA with action &quot;login&quot;.</span></span><br><span class="line">  <span class="keyword">const</span> token = <span class="keyword">await</span> <span class="title function_">executeRecaptcha</span>(<span class="string">&#x27;login&#x27;</span>);</span><br><span class="line">  <span class="comment">// 後續傳給後端進行認證</span></span><br><span class="line">  <span class="comment">// Do stuff with the received token.</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在需要用到 reCAPTCHA v3 的地方進行引入：</p>
<figure class="highlight typescript"><figcaption><span>GoogleReCaptchaV3.vue</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;script setup lang=<span class="string">&quot;ts&quot;</span>&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; useReCaptcha &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-recaptcha-v3&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useReCaptchaV3 &#125; <span class="keyword">from</span> <span class="string">&#x27;../composables/useReCaptchaV3&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> useReCaptchaInstance = <span class="title function_">useReCaptcha</span>()!;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><figcaption><span>GoogleReCaptchaV3.vue</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;v3-margin&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">click</span>=<span class="string">&quot;useReCaptchaV3(useReCaptchaInstance)&quot;</span>&gt;</span></span><br><span class="line">        Submit to active reCAPTCHA</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span> <span class="attr">lang</span>=<span class="string">&quot;css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.v3-margin</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>這樣一樣可以完成觸發，且更彈性、靈活，可以在各處依照需求引入！</p>
<p><img src="/blog/images/vue-google-recaptcha/post_content_img_13.png"></p>
<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>那到目前為止，就完成了 Google reCAPTCHA v2 v3 的實作了，在依照跟後端的溝通進行驗證即可~沒有遇到什麼困難，算是很好接的 Google Api 了 XD</p>
<p>那這邊附上實作的範例檔案：<a href="https://github.com/ben890524/vue3-recaptcha-example">vue3-recaptcha-example</a>。</p>
<h6 id="tags-Vue-Google-reCAPTCHA"><a href="#tags-Vue-Google-reCAPTCHA" class="headerlink" title="tags: Vue Google reCAPTCHA"></a>tags: <code>Vue</code> <code>Google reCAPTCHA</code></h6>]]></content>
      <categories>
        <category>Frontend</category>
      </categories>
      <tags>
        <tag>Frontend</tag>
        <tag>Vue</tag>
        <tag>Google reCAPTCHA</tag>
      </tags>
  </entry>
</search>
